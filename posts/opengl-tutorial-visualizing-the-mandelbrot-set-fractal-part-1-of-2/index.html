<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2" /><meta property="og:locale" content="en" /><meta name="description" content="Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of my spare time teaching myself the ins and outs of the OpenGL api and in doing so have created some projects along the way. In this specific tutorial set I wanted to guide you through creating one of my earlier projects which I completed some time in January of 2020. That being a program which displays a stylised version of the Mandelbrot Set fractal pattern. I would have loved to have found all of this information condensed in one post when making it and so I hope this will be of benefit to you. In terms of the knowledge required to understand this tutorial, I wrote my programs in Java and would like this to be a tutorial one can learn from scratch with no prior OpenGL experience. I am going to attempt to explain the basic concepts in OpenGL as best I can meaning you will only need some experience with an object oriented programming language to understand it all. I will also regularly supply other sources for reading up on any concepts mentioned throughout." /><meta property="og:description" content="Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of my spare time teaching myself the ins and outs of the OpenGL api and in doing so have created some projects along the way. In this specific tutorial set I wanted to guide you through creating one of my earlier projects which I completed some time in January of 2020. That being a program which displays a stylised version of the Mandelbrot Set fractal pattern. I would have loved to have found all of this information condensed in one post when making it and so I hope this will be of benefit to you. In terms of the knowledge required to understand this tutorial, I wrote my programs in Java and would like this to be a tutorial one can learn from scratch with no prior OpenGL experience. I am going to attempt to explain the basic concepts in OpenGL as best I can meaning you will only need some experience with an object oriented programming language to understand it all. I will also regularly supply other sources for reading up on any concepts mentioned throughout." /><link rel="canonical" href="https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/" /><meta property="og:url" content="https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/" /><meta property="og:site_name" content="Cian Jinks" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-16T13:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2" /><meta name="twitter:site" content="@cianjinks" /><meta name="google-site-verification" content="google467373ea47fceddf" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-20T17:53:53+00:00","datePublished":"2020-05-16T13:00:00+01:00","description":"Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of my spare time teaching myself the ins and outs of the OpenGL api and in doing so have created some projects along the way. In this specific tutorial set I wanted to guide you through creating one of my earlier projects which I completed some time in January of 2020. That being a program which displays a stylised version of the Mandelbrot Set fractal pattern. I would have loved to have found all of this information condensed in one post when making it and so I hope this will be of benefit to you. In terms of the knowledge required to understand this tutorial, I wrote my programs in Java and would like this to be a tutorial one can learn from scratch with no prior OpenGL experience. I am going to attempt to explain the basic concepts in OpenGL as best I can meaning you will only need some experience with an object oriented programming language to understand it all. I will also regularly supply other sources for reading up on any concepts mentioned throughout.","headline":"OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/"},"url":"https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/"}</script><title>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2 | Cian Jinks</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Cian Jinks"><meta name="application-name" content="Cian Jinks"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/avatar/hobbes_3.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Cian Jinks</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cianjinks" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/cianjinks" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['cjinks99','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/cianjinks">Cian Jinks</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1589630400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-05-16 </em> </span> <span> Updated <em class="timeago" data-ts="1645379633" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-02-20 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5656 words"> <em>31 min</em> read</span></div></div></div><div class="post-content"><p>Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of my spare time teaching myself the ins and outs of the OpenGL api and in doing so have created some projects along the way. In this specific tutorial set I wanted to guide you through creating one of my earlier projects which I completed some time in January of 2020. That being a program which displays a stylised version of the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot Set</a> fractal pattern. I would have loved to have found all of this information condensed in one post when making it and so I hope this will be of benefit to you. In terms of the knowledge required to understand this tutorial, I wrote my programs in Java and would like this to be a tutorial one can learn from scratch with no prior OpenGL experience. I am going to attempt to explain the basic concepts in OpenGL as best I can meaning you will only need some experience with an object oriented programming language to understand it all. I will also regularly supply other sources for reading up on any concepts mentioned throughout.</p><p>(If you simply wish to learn how to create the Mandelbrot Set shader please check out <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/">part two</a> of this tutorial)</p><p>One last thing before I dive right into the explanations is that a further updated and completed version of this project with all of the source code as well as compiled jars can be found over on my project’s github page called <a href="https://github.com/cianjinks/MandelbrotViewer">Mandelbrot-Viewer</a> so I encourage giving that a look too.</p><h2 id="getting-started"><span class="mr-2">Getting Started</span><a href="#getting-started" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>First things first for those who don’t know, what is OpenGL? OpenGL aims to be a cross platform computer graphics api. This means in theory you can use it to communicate with GPUs on various systems and platforms that exist today. <em>However,</em> note that I referred to it as an api. At its core OpenGL is simply a specification of commands that one should be able to send to their GPU to make it perform graphics calculations. It is generally up to third parties to provide the implementations of this api. Luckily for us OpenGL is relatively popular and so pretty much all modern graphics cards support it (although much older graphics cards only support up to specific versions) and there are bindings for it available in a wide variety of programming languages. For this tutorial I will be writing in Java and thus using <a href="https://www.lwjgl.org/">LWJGL</a> for the OpenGL bindings. LWJGL also comes with some other useful libraries with the most notable for us being GLFW which is used for the creation of an application window which we can then draw to on various operating systems. Since OpenGL is a specification any OpenGL methods that I do use throughout this tutorial should have a largely similar method signature using other bindings and languages making it hopefully no problem for following along.</p><p>If you do want to follow this tutorial directly note that I selected the Minimal OpenGL configuration on LWJGL’s <a href="https://www.lwjgl.org/customize">customize page</a> and added the JOML math library addon. I also chose to use Maven for compiling my program and binaries. If you don’t know how Maven works I will soon be writing a tutorial about setting up a Maven Java project for OpenGL programming and will use this tutorial as an example.</p><p><strong>EDIT:</strong> That tutorial can now be found <a href="https://cianjinks.github.io/posts/tutorial-using-maven-and-intellij-for-opengl-projects/">here</a>.</p><h2 id="the-window"><span class="mr-2">The Window</span><a href="#the-window" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>To begin our program we are going to want to use GLFW to create a window for our respective operating system. I am using Windows for my OS but everything should work relatively the same cross platform. To do so is relatively simple as we can just head on over to the <a href="https://www.lwjgl.org/guide">LWJGL starter page</a> and grab their code for starting a window. I chose to place it in a class called <code class="language-plaintext highlighter-rouge">Application</code>. As for what this code does, it provides three functions named <code class="language-plaintext highlighter-rouge">run</code>, <code class="language-plaintext highlighter-rouge">init</code> and <code class="language-plaintext highlighter-rouge">loop</code> which are run consecutively when the program starts. Our window is created within <code class="language-plaintext highlighter-rouge">init</code> using <code class="language-plaintext highlighter-rouge">glfwCreateWindow</code> and some other configuration options are set. Most of these have explanatory comments provided however if you wish to investigate further as to what these various functions do you can check out <a href="https://www.glfw.org/docs/latest/">GLFW’s documentation</a>. Do note that examples are provided in C++ not Java. After <code class="language-plaintext highlighter-rouge">glfwCreateWindow</code> some key callbacks are set up which can be used to detect the pressing of keys. The only one used for the time being is the escape key to close the window. At the moment the only thing we wish to modify here would be the window proportions. For this project I chose to set the width and height to 480x480 (960x960 would also work fine, as would any square size) making for a perfect square which will simplify things later on.</p><p>The next area of code we need to worry about is within <code class="language-plaintext highlighter-rouge">loop</code>. Here you will notice a while loop which waits until the window is closed before completing. This will act as our program’s main loop meaning in here we will place code we want to run every frame drawn to the screen (All code here should be placed <em>before</em> the <code class="language-plaintext highlighter-rouge">glfwSwapBuffers</code> function). Just to make sure that this starter code all works correctly we can go ahead and run the program and should be greeted with a square window colored red due to the <code class="language-plaintext highlighter-rouge">glClearColor</code> method in <code class="language-plaintext highlighter-rouge">loop</code>. For reference here is how our code should look so far:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.lwjgl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.glfw.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.opengl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.system.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.nio.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">Callbacks</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">GLFW</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">opengl</span><span class="o">.</span><span class="na">GL11</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryStack</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryUtil</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="c1">// The window handle</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">window</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello LWJGL "</span> <span class="o">+</span> <span class="nc">Version</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>

        <span class="n">init</span><span class="o">();</span>
        <span class="n">loop</span><span class="o">();</span>

        <span class="c1">// Free the window callbacks and destroy the window</span>
        <span class="n">glfwFreeCallbacks</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="n">glfwDestroyWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>

        <span class="c1">// Terminate GLFW and free the error callback</span>
        <span class="n">glfwTerminate</span><span class="o">();</span>
        <span class="n">glfwSetErrorCallback</span><span class="o">(</span><span class="kc">null</span><span class="o">).</span><span class="na">free</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Setup an error callback. The default implementation</span>
        <span class="c1">// will print the error message in System.err.</span>
        <span class="nc">GLFWErrorCallback</span><span class="o">.</span><span class="na">createPrint</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">).</span><span class="na">set</span><span class="o">();</span>

        <span class="c1">// Initialize GLFW. Most GLFW functions will not work before doing this.</span>
        <span class="k">if</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwInit</span><span class="o">()</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Unable to initialize GLFW"</span><span class="o">);</span>

        <span class="c1">// Configure GLFW</span>
        <span class="n">glfwDefaultWindowHints</span><span class="o">();</span> <span class="c1">// optional, the current window hints are already the default</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_VISIBLE</span><span class="o">,</span> <span class="no">GLFW_FALSE</span><span class="o">);</span> <span class="c1">// the window will stay hidden after creation</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_RESIZABLE</span><span class="o">,</span> <span class="no">GLFW_TRUE</span><span class="o">);</span> <span class="c1">// the window will be resizable</span>

        <span class="c1">// Create the window</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="o">(</span><span class="mi">960</span><span class="o">,</span> <span class="mi">960</span><span class="o">,</span> <span class="s">"Hello World!"</span><span class="o">,</span> <span class="no">NULL</span><span class="o">,</span> <span class="no">NULL</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span> <span class="n">window</span> <span class="o">==</span> <span class="no">NULL</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Failed to create the GLFW window"</span><span class="o">);</span>

        <span class="c1">// Setup a key callback. It will be called every time a key is pressed, repeated or released.</span>
        <span class="n">glfwSetKeyCallback</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">scancode</span><span class="o">,</span> <span class="n">action</span><span class="o">,</span> <span class="n">mods</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span> <span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span> <span class="o">)</span>
                <span class="n">glfwSetWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// We will detect this in the rendering loop</span>
        <span class="o">});</span>

        <span class="c1">// Get the thread stack and push a new frame</span>
        <span class="k">try</span> <span class="o">(</span> <span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">stackPush</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
            <span class="nc">IntBuffer</span> <span class="n">pWidth</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>
            <span class="nc">IntBuffer</span> <span class="n">pHeight</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>

            <span class="c1">// Get the window size passed to glfwCreateWindow</span>
            <span class="n">glfwGetWindowSize</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">pWidth</span><span class="o">,</span> <span class="n">pHeight</span><span class="o">);</span>

            <span class="c1">// Get the resolution of the primary monitor</span>
            <span class="nc">GLFWVidMode</span> <span class="n">vidmode</span> <span class="o">=</span> <span class="n">glfwGetVideoMode</span><span class="o">(</span><span class="n">glfwGetPrimaryMonitor</span><span class="o">());</span>

            <span class="c1">// Center the window</span>
            <span class="n">glfwSetWindowPos</span><span class="o">(</span>
                    <span class="n">window</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">-</span> <span class="n">pWidth</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">height</span><span class="o">()</span> <span class="o">-</span> <span class="n">pHeight</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="o">);</span>
        <span class="o">}</span> <span class="c1">// the stack frame is popped automatically</span>

        <span class="c1">// Make the OpenGL context current</span>
        <span class="n">glfwMakeContextCurrent</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="c1">// Enable v-sync</span>
        <span class="n">glfwSwapInterval</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Make the window visible</span>
        <span class="n">glfwShowWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Application</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><p>This will produce the following window:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_1.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_1.png" data-proofer-ignore></p><h2 id="vertices"><span class="mr-2">Vertices</span><a href="#vertices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that we have got the window set up it is nearly time to get to graphics programming. But first there are a few basic concepts that need to be understood. The way in which modern graphics work is that any shape, image or 3d mesh that one wishes to be rendered to a screen is made up of polygons. For more complex work there can sometimes be thousands of said polygons that make up a single shape or model. The most efficient form of polygons for graphics programming are triangles. Each triangle consists of three points and three lines joining all of those points together to form the triangle. Each of these points is what is referred to as a vertex and together they are vertices. However, you should not think of vertices as just the corners/points making up a triangle implying all they can contain is a position. While they do contain a position, in OpenGL these vertices can in fact contain all kinds of data about a given triangle such as color, texture coordinates, lighting information and more.</p><p>For our program we will only need to render a simple square to the screen and won’t require the vertices to store anything more than their positions. One last thing to note is that, by default, positions in OpenGL range from -1.0 to 1.0 for the x and y coordinates of the screen. With that in mind here is how we would go about creating a square out of triangle polygons which fills the entire window (because the very bottom left in OpenGL is (-1.0, -1.0) and the top right is (1.0, 1.0)):</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_2.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_2.png" data-proofer-ignore></p><p>As can be seen all that is needed is two right angled triangles joined together. These can be defined using just four vertices with positions of (-1.0, 1.0), (-1.0, -1.0), (1.0, -1.0) and (1.0, 1.0) so that they fill up the whole screen. In general, when implementing the handling of vertices in code, one would likely wish to create a <code class="language-plaintext highlighter-rouge">Vertex</code> class to allow the creation of an arbitrary number of vertices each with their unique data. However, in our case we only will be using four vertices so it is easier to just hardcode their position data into an array as follows (this code will be placed in our <code class="language-plaintext highlighter-rouge">loop</code> method <em>before</em> the actual main window while loop):</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Vertices - Positions</span>
<span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
    <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
    <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
     <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
     <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
<span class="o">};</span>
</pre></table></code></div></div><h2 id="vertex-buffers"><span class="mr-2">Vertex Buffers</span><a href="#vertex-buffers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now you might be asking yourself how is it that we actually pass this data to our graphics card through OpenGL? This is where the concept of a vertex buffer comes into play. A vertex buffer is simply an area of memory on your gpu which stores information about your various vertices. The way in which we actually place our data there is through the use of a few OpenGL functions which specify how our vertices will be laid out in memory and allow us to place the vertex data into that memory. Before any of that however, there is one more thing we must do in Java specifically which is to transfer our <code class="language-plaintext highlighter-rouge">vertices</code> array we created above to a <code class="language-plaintext highlighter-rouge">FloatBuffer</code>. This is common practice when using Java for OpenGL and if you wish to learn why that is I encourage doing some googling or checking out this <a href="https://stackoverflow.com/questions/18913001/when-to-use-array-buffer-or-direct-buffer">stackoverflow post</a>.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// VBO (Vertex Buffer Object)</span>
<span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>
</pre></table></code></div></div><p>You’ll notice that we needed to run <code class="language-plaintext highlighter-rouge">flip</code> on our buffer at the end. The reasoning for this can be found <a href="https://stackoverflow.com/questions/29397407/gldrawbuffers-should-have-flipped-intbuffer">here</a>.</p><p>Now we can finally pass our data to our gpu through some functions provided by OpenGL:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Pass data to GPU</span>
<span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</pre></table></code></div></div><p>There is quite a bit going on here so I will try to break it down. However I don’t want to spend overly long on it so if you are still confused I highly recommend checking out the <a href="http://docs.gl/">docs.gl</a> website for further reading on what each function does and the various parameters that can be passed to it. (In this tutorial I use OpenGL 3.0 so when checking for functions on docs.gl select their gl3 counterpart).</p><h3 id="glgenbuffers"><span class="mr-2">glGenBuffers</span><a href="#glgenbuffers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Here we are telling OpenGL we wish to create a buffer on the gpu where we can store some information. This function will return us an ID in the form of an Integer which we can later use to reference this same buffer.</p><h3 id="glbindbuffer"><span class="mr-2">glBindBuffer</span><a href="#glbindbuffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>When we want to modify a buffer we have created we must first bind it. When doing so we specify the type of buffer it is which in our case is a <code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code>. If you check out the <a href="http://docs.gl/">docs.gl</a> page for <code class="language-plaintext highlighter-rouge">glBindBuffer</code> you’ll note it says this type of buffer is used for storing vertex attributes. Vertex attributes are the different pieces of data our vertex stores as mentioned before - position, color, texture coordinates, lighting information and anything else you may want.</p><h3 id="glbufferdata"><span class="mr-2">glBufferData</span><a href="#glbufferdata" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This function is where we actually pass our vertices data to the gpu. We tell it the type of data that we are placing within the buffer which is once again vertex attributes (denoted by <code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code>) and then we tell it to use <code class="language-plaintext highlighter-rouge">GL_STATIC_DRAW</code>. This means the data we pass is going to be used for drawing to the screen and will not be modified again in the future. As you might guess this means we cannot manipulate the vertices on the fly as the program is running which for us is all that we need. If you wish to learn about how one would do such a thing, to allow the moving of vertices and more, I will have another tutorial coming soon which I will link here.</p><h3 id="glvertexattribpointer"><span class="mr-2">glVertexAttribPointer</span><a href="#glvertexattribpointer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Now that we have provided our vertex data to the gpu how does it know what that data means? We need to explain to it the layout of our memory and what each byte is for. This is where <code class="language-plaintext highlighter-rouge">glVertexAttribPointer</code> is used. The first parameter which we have passed is 0. This simply tells the GPU this is our first vertex attribute. After that we need to tell it how many pieces of data make up that attribute. In our case we have four positions specified in our array where each position requires an x and a y. This means that each attribute is made up of two pieces of data. The type of this data is then specified next as <code class="language-plaintext highlighter-rouge">GL_FLOAT</code> in our case because each x and y position is a float. <code class="language-plaintext highlighter-rouge">false</code> then tells it this data is not normalised. The GPU still needs to know one more thing which is how many bytes each of our position attributes take up. You might wonder why this is necessary since it already knows their type and how many of that type are in each? However, when you have multiple different vertex attributes it needs to know where each one starts. In our case we have two floats worth of bytes which I have calculated by <code class="language-plaintext highlighter-rouge">positionElementCount * Float.BYTES</code>. Finally the last parameter tells it where the first occurence of this vertex attribute begins in our vertex buffer. Since this is our only vertex attribute it begins at position 0.</p><p>Once again a much more detailed explanation of this function is found on its <a href="http://docs.gl/gl4/glVertexAttribPointer">docs.gl page</a>.</p><h3 id="glenablevertexattribarray"><span class="mr-2">glEnableVertexAttribArray</span><a href="#glenablevertexattribarray" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>This last function simply enables our first vertex attribute (index 0).</p><p>With that out of the way our vertex buffer is now complete! Here is what our <code class="language-plaintext highlighter-rouge">loop</code> function should now look like in its entirety:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Vertices - Positions</span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
                 <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
                 <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
        <span class="o">};</span>

        <span class="c1">// VBO (Vertex Buffer Object)</span>
        <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
	<span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="index-buffers"><span class="mr-2">Index Buffers</span><a href="#index-buffers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The next important concept in OpenGL required for us to draw a square are index buffers. So far we have passed to the gpu the positions of our four vertices that are going to make up our square and explained how these positions are laid out in memory. However, we still haven’t explained to the gpu how it should make use of this data. How does it know to draw two right angled triangles using these vertex positions? This is where index buffers come into play. We can use an index buffer to specify which vertices make up our triangles by storing some indices within it:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Indices</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
	<span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
  	<span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
<span class="o">};</span>
</pre></table></code></div></div><p>In this setup we are saying that one of our right angled triangles is going to be made up of vertex 0, 1 and 2 and the other will be made up of vertex 2, 3 and 0. Note that the order in which these are specified is counter clockwise with respect to the diagram shown in the vertices section of the tutorial.</p><p>To pass these indices to the gpu we are going to create an index buffer. This process is much the same as the vertex buffer although slightly simpler:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// IBO (Index Buffer Object)</span>
<span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
 	<span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

<span class="c1">// Pass data to GPU</span>
<span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
</pre></table></code></div></div><p>One slight difference from the vertex buffer is the use of <code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code> instead of <code class="language-plaintext highlighter-rouge">GL_ARRAY_BUFFER</code>. This type of buffer is used for storing vertex indices instead of vertex attributes.</p><p>With that we are all done with our index buffers and our finalised code should look something like this:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Vertices - Positions</span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
                 <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
                 <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
        <span class="o">};</span>

        <span class="c1">// VBO (Vertex Buffer Object)</span>
        <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">// Indices</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
            <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
            <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
        <span class="o">};</span>

        <span class="c1">// IBO (Index Buffer Object)</span>
        <span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>


        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>If we want, we can now go ahead and try drawing our square using one more line of code in our main window loop:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// Run the rendering loop until the user has attempted to close</span>
<span class="c1">// the window or has pressed the ESCAPE key.</span>
<span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
    <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

    <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

    <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

    <span class="c1">// Poll for window events. The key callback above will only be</span>
    <span class="c1">// invoked during this call.</span>
    <span class="n">glfwPollEvents</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Here we are using <code class="language-plaintext highlighter-rouge">glDrawElements</code> to draw our vertices based on our index buffer which was a <code class="language-plaintext highlighter-rouge">GL_ELEMENT_ARRAY_BUFFER</code>. We use <code class="language-plaintext highlighter-rouge">GL_TRIANGLES</code> mode to specify we want it to take each group of three indices to form a triangle. After than we need to tell it how many indices we have placed in our index buffer up above which is simply the length of our array. Our indices are of course of type Integer and so we specify <code class="language-plaintext highlighter-rouge">GL_UNSIGNED_INT</code>. The very last parameter is a 0 as our indices start from index 0 in our index buffer.</p><p>We can then run our program. If you do get a crash here and are using a different language or OpenGL binding to follow this tutorial it is possible that that OpenGL binding does not come with a default shader so you will have to create one using the next section of the tutorial first. Otherwise using LWJGL you should get a fully white window as your white square now fills the window:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_3.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_3.png" data-proofer-ignore></p><p>Just to be 100% sure that it is working we could modify the position of Vertex 0 to (-0.5, 1.0) which should reveal a slight bit of the original red background as our shape no longer covers that top left portion fully:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_4.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_4.png" data-proofer-ignore></p><h2 id="shaders"><span class="mr-2">Shaders</span><a href="#shaders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Some of you may have already heard of shaders before. They are one of the biggest features of OpenGL and are what allow us to customise the look of our square as we please. Eventually we are going to write a shader which visualizes the mandelbrot set however for the time being, as a good introduction to shaders, we will simply write a shader to color our square purple. We won’t delve particularly deep into the various features offered by shaders here but if you wish to research further there are numerous resources online for doing so.</p><p>The first thing you need to know is that shaders are written in their own programming language called GLSL (GL Shading Language). Don’t worry though, it is relatively simple to figure out if you already have experience programming in general. If you do end up wanting to learn much more about it after this tutorial you can check out this <a href="https://youtu.be/HIvNePu7UEE?list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7">youtube series</a>.</p><p>Before we write any shaders of our own we first need to do some set up in our code for handling them. Since they’re going to be written in their own language it is common practice to store them in their own files. When we need to pass them to the gpu we will load them in from their respective file as a string. In java I will use a simple <code class="language-plaintext highlighter-rouge">BufferedReader</code> and it’s concept of streams to read in the contents of a file and return them as a string via the function <code class="language-plaintext highlighter-rouge">parseShaderFromFile</code>. In other languages and on other systems this will likely work differently and you will need to make sure that new line characters are captured accurately as well otherwise your shader will not compile and will produce no errors as we do not have any error handling implemented.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">parseShaderFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">)));</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
        <span class="o">{</span>
            <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load shader from: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>With that function setup we can then use it in our code to load in our shaders and send them to our gpu:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Shaders</span>
<span class="kt">int</span> <span class="n">programID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateProgram</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">vertShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_VERTEX_SHADER</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">fragShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_FRAGMENT_SHADER</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/vert.shader"</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">,</span> <span class="n">vertexShader</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/frag.shader"</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">,</span> <span class="n">fragmentShader</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">vertShaderObj</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">fragShaderObj</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glLinkProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glValidateProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
<span class="no">GL30</span><span class="o">.</span><span class="na">glUseProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
</pre></table></code></div></div><p>We do a good bit here so I will try my best to explain. First we must create a program for which to bind our shaders using <code class="language-plaintext highlighter-rouge">glCreateProgram</code>. There are multiple different types of shaders but by far the main two you should be aware of are Vertex shaders and Fragment shaders. Vertex shaders are run on each vertex of the polygon they are applied to and as a result are able to manipulate the various vertex attributes associated with them. On the other hand fragment shaders are run on every pixel in between these vertices meaning they can be used for texturing, coloring, lighting calculations and more. With that in mind we then use <code class="language-plaintext highlighter-rouge">glCreateShader</code> to tell the gpu we want a <code class="language-plaintext highlighter-rouge">GL_VERTEX_SHADER</code> and a <code class="language-plaintext highlighter-rouge">GL_FRAGMENT_SHADER</code>. This function will return an integer to act as a handler which we can use to reference that same shader again in the future. Next we have to provide this shader to the gpu using <code class="language-plaintext highlighter-rouge">glShaderSource</code>. Just before doing that you can see we load each shader from their respective file into a string using the <code class="language-plaintext highlighter-rouge">parseShaderFromFile</code> method. I am storing the shaders in a location relative to my maven project (specifically the resources folder) but your file path may of course be different.</p><p>For a majority of the rest of the functions used here you get a basic idea of what they do from reading them and you don’t necessarily need to know what they do at a lower level but if you wish to delve deeper check out <a href="http://docs.gl/">docs.gl</a> once again.</p><p>Finally we can begin writing our own shaders. For now we will simply color our square purple but in part two of this tutorial this is where we will write the code within the fragment shader to generate the mandelbrot set.</p><h3 id="vertex-shader"><span class="mr-2">Vertex Shader</span><a href="#vertex-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// /shaders/vert.shader</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">position</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This is going to be the basic outline for our vertex shader. The very first line takes in our vertex attribute placed at index 0 which is the position of each of our vertices that we set up way back in our vertex buffer. GLSL supports vectors which are made up of floats and since our position data is stored in groups of 2 floats we are going to store the position of the current vertex being processed by the shader in a vec2 (2 float vector) called <code class="language-plaintext highlighter-rouge">position</code>. After that we define a <code class="language-plaintext highlighter-rouge">main</code> which needs to be present in all shaders and provide that position to a special OpenGL variable called <code class="language-plaintext highlighter-rouge">gl_Position</code>. This variable is what internally determines the position of the current vertex being processed by our vertex shader. The reason for converting our position variable from a vec2 to a vec4 before passing it to <code class="language-plaintext highlighter-rouge">gl_Position</code> is because OpenGL uses an xyzw coordinate system. An explanation for the reasoning as to why there is an extra w coordinate can be found <a href="https://stackoverflow.com/questions/2422750/in-opengl-vertex-shaders-what-is-w-and-why-do-i-divide-by-it">here</a>.</p><h3 id="fragment-shader"><span class="mr-2">Fragment Shader</span><a href="#fragment-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Our fragment shader is even simpler than our vertex shader. All it does is set another built in OpenGL variable, that being <code class="language-plaintext highlighter-rouge">gl_FragColor</code>, which controls the color of the pixels between our vertices. In this case we are just setting it to a purple color in RGBA. RGBA values range from 0.0 to 1.0 in OpenGL instead of the usual 0 to 255.</p><p>With that, we are all done! We can run our program and should see a nice purple window which is our square:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_5.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_5.png" data-proofer-ignore></p><p>This entire process may have seemed overly long and tedious just to produce a simple square but as we explore more in the next part of this tutorial and hopefully in future tutorials it will begin to become clear just how useful and powerful this all is. Once you begin to add layers of abstraction it can simplify things much further as well.</p><p>For reference here is the <code class="language-plaintext highlighter-rouge">loop</code> function in its entirety along with <code class="language-plaintext highlighter-rouge">parseShaderFromFile</code>:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
    <span class="c1">// OpenGL context, or any context that is managed externally.</span>
    <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
    <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
    <span class="c1">// bindings available for use.</span>
    <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

    <span class="c1">// Set the clear color</span>
    <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

    <span class="c1">// Vertices - Positions</span>
    <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
            <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
            <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
             <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
             <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
    <span class="o">};</span>

    <span class="c1">// VBO (Vertex Buffer Object)</span>
    <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

    <span class="c1">// Pass data to GPU</span>
    <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

    <span class="c1">// Indices</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
        <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
        <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
    <span class="o">};</span>

    <span class="c1">// IBO (Index Buffer Object)</span>
    <span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

    <span class="c1">// Pass data to GPU</span>
    <span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>

    <span class="c1">// Shaders</span>
    <span class="kt">int</span> <span class="n">programID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateProgram</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">vertShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_VERTEX_SHADER</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">fragShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_FRAGMENT_SHADER</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/vert.shader"</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">,</span> <span class="n">vertexShader</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/frag.shader"</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">,</span> <span class="n">fragmentShader</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">vertShaderObj</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">fragShaderObj</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glLinkProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glValidateProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glUseProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>

    <span class="c1">// Run the rendering loop until the user has attempted to close</span>
    <span class="c1">// the window or has pressed the ESCAPE key.</span>
    <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
        <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

        <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

        <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

        <span class="c1">// Poll for window events. The key callback above will only be</span>
        <span class="c1">// invoked during this call.</span>
        <span class="n">glfwPollEvents</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">parseShaderFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">StringBuilder</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">)));</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
        <span class="o">{</span>
            <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load shader from: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="part-2"><span class="mr-2">Part 2</span><a href="#part-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>The <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/">next part</a> of this tutorial will cover some more advanced concepts such as how we can set up a simple camera using user input and an MVP Matrix (Model View Projection). That is also where we will write a fragment shader to visualize the Mandelbrot Set Fractal on our square and discuss some of its limitations. If you’ve already made it this far thanks so much for reading and I hope I was able to help you learn a bit along the way :D</p><p>- Cian Jinks</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/old/'>Old</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/opengl/" class="post-tag no-text-decoration" >opengl</a> <a href="/tags/lwjgl/" class="post-tag no-text-decoration" >lwjgl</a> <a href="/tags/fractal/" class="post-tag no-text-decoration" >fractal</a> <a href="/tags/tutorial/" class="post-tag no-text-decoration" >tutorial</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2 - Cian Jinks&amp;url=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2 - Cian Jinks&amp;u=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/&amp;text=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2 - Cian Jinks" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cmake-project-graphics-programming/">Creating a CMake Project for cross platform graphics programming with OpenGL</a><li><a href="/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/">OpenGL Tutorial - Batch Rendering and Dynamic VBOs</a><li><a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2</a><li><a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/">Tutorial - Using Maven and IntelliJ for OpenGL Projects</a><li><a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/">OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/lwjgl/">lwjgl</a> <a class="post-tag" href="/tags/fractal/">fractal</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/imgui/">imgui</a> <a class="post-tag" href="/tags/maven/">maven</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/"><div class="card-body"> <em class="timeago small" data-ts="1590926400" > 2020-05-31 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2</h3><div class="text-muted small"><p> This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fr...</p></div></div></a></div><div class="card"> <a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/"><div class="card-body"> <em class="timeago small" data-ts="1590667200" > 2020-05-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tutorial - Using Maven and IntelliJ for OpenGL Projects</h3><div class="text-muted small"><p> This tutorial will quickly cover how one can use Maven along with IntelliJ to get started with graphics programming using OpenGL. I originally wrote this so people could use it to directly follow a...</p></div></div></a></div><div class="card"> <a href="/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/"><div class="card-body"> <em class="timeago small" data-ts="1591963200" > 2020-06-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenGL Tutorial - Batch Rendering and Dynamic VBOs</h3><div class="text-muted small"><p> Hello and welcome to my second ever tutorial on computer graphics programming using OpenGL. My previous tutorials covered many of the basics of OpenGL such as VBOs, IBOs, Shaders and MVP Matrices b...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/hacktrinity-ctf-write-up/" class="btn btn-outline-primary" prompt="Older"><p>HackTrinity CTF Write Up</p></a> <a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/" class="btn btn-outline-primary" prompt="Newer"><p>Tutorial - Using Maven and IntelliJ for OpenGL Projects</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/cianjinks">Cian Jinks</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/lwjgl/">lwjgl</a> <a class="post-tag" href="/tags/fractal/">fractal</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/imgui/">imgui</a> <a class="post-tag" href="/tags/maven/">maven</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-BJS97N23FL"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-BJS97N23FL'); }); </script>
