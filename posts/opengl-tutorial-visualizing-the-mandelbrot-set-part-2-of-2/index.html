<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2" /><meta property="og:locale" content="en" /><meta name="description" content="This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fragment shader responsible for generating the fractal. If you are interested in how to draw a square to the screen with shaders applied to it, check out part one. This part is going to continue from where we left off in part one (a simple square colored purple using shaders)." /><meta property="og:description" content="This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fragment shader responsible for generating the fractal. If you are interested in how to draw a square to the screen with shaders applied to it, check out part one. This part is going to continue from where we left off in part one (a simple square colored purple using shaders)." /><link rel="canonical" href="https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/" /><meta property="og:url" content="https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/" /><meta property="og:site_name" content="Cian Jinks" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-05-31T13:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2" /><meta name="twitter:site" content="@cianjinks" /><meta name="google-site-verification" content="google467373ea47fceddf" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-20T17:53:53+00:00","datePublished":"2020-05-31T13:00:00+01:00","description":"This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fragment shader responsible for generating the fractal. If you are interested in how to draw a square to the screen with shaders applied to it, check out part one. This part is going to continue from where we left off in part one (a simple square colored purple using shaders).","headline":"OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/"},"url":"https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/"}</script><title>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2 | Cian Jinks</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Cian Jinks"><meta name="application-name" content="Cian Jinks"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/avatar/hobbes_3.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Cian Jinks</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cianjinks" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/cianjinks" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['cjinks99','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2</h1><div class="post-meta text-muted"><div> By <em> <a href="https://twitter.com/cianjinks">Cian Jinks</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1590926400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-05-31 </em> </span> <span> Updated <em class="timeago" data-ts="1645379633" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-02-20 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8862 words"> <em>49 min</em> read</span></div></div></div><div class="post-content"><p>This is part 2 of my tutorial series on Visualizing the Mandelbrot Set Fractal using OpenGL. This part will cover the creation of a camera for zooming in and out and moving around as well as the fragment shader responsible for generating the fractal. If you are interested in how to draw a square to the screen with shaders applied to it, check out <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">part one</a>. This part is going to continue from where we left off in part one (a simple square colored purple using shaders).</p><h2 id="the-camera"><span class="mr-2">The Camera</span><a href="#the-camera" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="mvp-matrix"><span class="mr-2">MVP Matrix</span><a href="#mvp-matrix" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>The first thing to learn when it comes to creating our camera is the basics of what an MVP Matrix or Model View Projection Matrix is. When you have a 3D space or game and want to implement a camera you are going to need some way to convert what the camera sees to a 2D screen. This is where the MVP Matrix comes into play. Using some matrix multiplication and tricks one can easily convert rendered scenes into 2D screen space. An MVP Matrix is actually made up of three matrices multiplied together. Model * View * Projection. In this tutorial we are going to only be dealing with the Projection Matrix of the MVP Matrix as that is all that we need. If you do wish to research further (such as for a 3D project) <a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/">here</a> is a great tutorial on the topic.</p><p>The Projection Matrix is the last part in the process of converting a 3D object to 2D screen space coordinates. However, because all we have is simply a 2D scene we don’t need to deal with converting our object to 2D coordinates as it already is. Therefore we can simply use the Projection Matrix to “move” our object around. In reality, what we are really doing is moving our <em>camera</em> that looks at our object around. We are not modifying any of the vertex position attributes of our square. We can also make the object appear closer or further away from the screen by scaling our cameras view. With that all in mind lets begin creating our Projection Matrix.</p><p>You may remember back at the start of part 1 we added the JOML addon to our LWJGL configuration. This addon is a great Java math library designed specifically for OpenGL which will provide us with many classes and functions for handling matrices and matrix math. In fact, it even provides some handy functions for generating our projection matrix for us:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Projection Matrix</span>
<span class="kd">private</span> <span class="nc">Matrix4f</span> <span class="n">pmatrix</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">ortho</span><span class="o">(-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">);</span>
</pre></table></code></div></div><p>Much of this code is based off of JOML’s <a href="https://github.com/JOML-CI/JOML">README</a>. The first thing we do is create a new 4*4 square matrix filled with floats. This is going to be our projection matrix. We then apply an orthographic projection to it using <code class="language-plaintext highlighter-rouge">ortho()</code>. The parameters for this are going to be our camera views bounds. The first -2.0f and 2.0f correspond to the horizontal coordinates of our screen. If you remember from part one the default OpenGL coordinates range from -1.0f to 1.0f. In our case this change is simply making it range from -2.0f to 2.0f. The next -2.0f and 2.0f correspond to the same thing except vertically. Finally the -1.0f, 1.0f is for the z-direction. This doesn’t necessarily matter to us as we aren’t going to be moving anything in that direction so I simply set it to the OpenGL default. Note that I am declaring this as an instance variable at the top of our program as it is going to need to be accessible by all areas of our program so that we can modify it using user input.</p><p>Before that, however, we should first try applying it to our square. But how do we do that? What we want to do is multiply this matrix by our gl_Position in our fragment shader. Therefore we need some way to pass this matrix into our shader. The passing of information from the CPU to shaders is done via something called uniforms.</p><h3 id="uniforms"><span class="mr-2">Uniforms</span><a href="#uniforms" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To create a uniform on the cpu side we are going to need to two simple OpenGL functions:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Camera</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
  <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
  <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
  <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Note that this example uses correct LWJGL memory management practices as mentioned on the JOML <a href="https://github.com/JOML-CI/JOML">README</a> by first placing our matrix in a FloatBuffer before passing it as the data for our uniform. If you wish to read the documentation for a <code class="language-plaintext highlighter-rouge">Matrix4f</code> it can be found <a href="https://joml-ci.github.io/JOML/apidocs/org/joml/Matrix4f.html">here</a>.</p><p>The first of these OpenGL functions is <code class="language-plaintext highlighter-rouge">glGetUniformLocation</code>. This takes in the shader’s program ID which already exists in our program as well what you wish to call this uniform’s variable. In my case I like to use the convention of “u_Something” when naming uniforms. This function then returns us an Integer which we can use to reference this uniform later on. Next we use <code class="language-plaintext highlighter-rouge">glUniformMatrix4fv</code> and pass it this Integer. This tells OpenGL we want this uniform to be a 4*4 square matrix of floats. After that we pass it <code class="language-plaintext highlighter-rouge">false</code> so that it does not transpose the matrix (this can be necessary as other graphics apis like DirectX use different matrix ordering in memory) and finally we pass in our FloatBuffer which contains our projection matrix. This code should be placed in the main loop of the program, as we will want to be able to update the matrix to move the camera around every frame. If you want to learn more about any of these OpenGL functions, just like in <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">part one</a>, I highly recommend checking out <a href="http://docs.gl/">docs.gl</a>.</p><p>Finally we are going to head on over to our Vertex Shader called <code class="language-plaintext highlighter-rouge">vert.shader</code> and add in a small bit of extra code to make use of this projection matrix:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">position</span><span class="p">;</span>

<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">u_MVP</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">u_MVP</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, at the top we take in the uniform using its variable name we chose above and then multiply it by the position of each of our vertices before passing them to <code class="language-plaintext highlighter-rouge">gl_Positon</code>.</p><p>If we now go ahead and run our program it should produce the following window:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_6.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_6.png" data-proofer-ignore></p><p>As you can see, we have now changed the window’s scale from its original -1.0f to 1.0f to -2.0f to 2.0f. However, we have left the coordinates of our squares vertices the same and so now it only takes up a quarter of the screen in the center. The reasoning for making our screen coordinates range from -2.0f to 2.0f on both axises will become apparent once we start discussing the Mandelbrot Set calculations.</p><p>Here is how our <code class="language-plaintext highlighter-rouge">Application.java</code> should look now:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.joml.Matrix4f</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.glfw.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.opengl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.system.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">Callbacks</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">GLFW</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">opengl</span><span class="o">.</span><span class="na">GL11</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryStack</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryUtil</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="c1">// The window handle</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">window</span><span class="o">;</span>

    <span class="c1">// Projection Matrix</span>
    <span class="kd">private</span> <span class="nc">Matrix4f</span> <span class="n">pmatrix</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">ortho</span><span class="o">(-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello LWJGL "</span> <span class="o">+</span> <span class="nc">Version</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>

        <span class="n">init</span><span class="o">();</span>
        <span class="n">loop</span><span class="o">();</span>

        <span class="c1">// Free the window callbacks and destroy the window</span>
        <span class="n">glfwFreeCallbacks</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="n">glfwDestroyWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>

        <span class="c1">// Terminate GLFW and free the error callback</span>
        <span class="n">glfwTerminate</span><span class="o">();</span>
        <span class="n">glfwSetErrorCallback</span><span class="o">(</span><span class="kc">null</span><span class="o">).</span><span class="na">free</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Setup an error callback. The default implementation</span>
        <span class="c1">// will print the error message in System.err.</span>
        <span class="nc">GLFWErrorCallback</span><span class="o">.</span><span class="na">createPrint</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">).</span><span class="na">set</span><span class="o">();</span>

        <span class="c1">// Initialize GLFW. Most GLFW functions will not work before doing this.</span>
        <span class="k">if</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwInit</span><span class="o">()</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Unable to initialize GLFW"</span><span class="o">);</span>

        <span class="c1">// Configure GLFW</span>
        <span class="n">glfwDefaultWindowHints</span><span class="o">();</span> <span class="c1">// optional, the current window hints are already the default</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_VISIBLE</span><span class="o">,</span> <span class="no">GLFW_FALSE</span><span class="o">);</span> <span class="c1">// the window will stay hidden after creation</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_RESIZABLE</span><span class="o">,</span> <span class="no">GLFW_TRUE</span><span class="o">);</span> <span class="c1">// the window will be resizable</span>

        <span class="c1">// Create the window</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="o">(</span><span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"Hello World!"</span><span class="o">,</span> <span class="no">NULL</span><span class="o">,</span> <span class="no">NULL</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span> <span class="n">window</span> <span class="o">==</span> <span class="no">NULL</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Failed to create the GLFW window"</span><span class="o">);</span>

        <span class="c1">// Setup a key callback. It will be called every time a key is pressed, repeated or released.</span>
        <span class="n">glfwSetKeyCallback</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">scancode</span><span class="o">,</span> <span class="n">action</span><span class="o">,</span> <span class="n">mods</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span> <span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span> <span class="o">)</span>
                <span class="n">glfwSetWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// We will detect this in the rendering loop</span>
        <span class="o">});</span>

        <span class="c1">// Get the thread stack and push a new frame</span>
        <span class="k">try</span> <span class="o">(</span> <span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">stackPush</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
            <span class="nc">IntBuffer</span> <span class="n">pWidth</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>
            <span class="nc">IntBuffer</span> <span class="n">pHeight</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>

            <span class="c1">// Get the window size passed to glfwCreateWindow</span>
            <span class="n">glfwGetWindowSize</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">pWidth</span><span class="o">,</span> <span class="n">pHeight</span><span class="o">);</span>

            <span class="c1">// Get the resolution of the primary monitor</span>
            <span class="nc">GLFWVidMode</span> <span class="n">vidmode</span> <span class="o">=</span> <span class="n">glfwGetVideoMode</span><span class="o">(</span><span class="n">glfwGetPrimaryMonitor</span><span class="o">());</span>

            <span class="c1">// Center the window</span>
            <span class="n">glfwSetWindowPos</span><span class="o">(</span>
                    <span class="n">window</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">-</span> <span class="n">pWidth</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">height</span><span class="o">()</span> <span class="o">-</span> <span class="n">pHeight</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="o">);</span>
        <span class="o">}</span> <span class="c1">// the stack frame is popped automatically</span>

        <span class="c1">// Make the OpenGL context current</span>
        <span class="n">glfwMakeContextCurrent</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="c1">// Enable v-sync</span>
        <span class="n">glfwSwapInterval</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Make the window visible</span>
        <span class="n">glfwShowWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Vertices - Positions</span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
                 <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
                 <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
        <span class="o">};</span>

        <span class="c1">// VBO (Vertex Buffer Object)</span>
        <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">// Indices</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
            <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
            <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
        <span class="o">};</span>

        <span class="c1">// IBO (Index Buffer Object)</span>
        <span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>

        <span class="c1">// Shaders</span>
        <span class="kt">int</span> <span class="n">programID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateProgram</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">vertShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_VERTEX_SHADER</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">fragShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_FRAGMENT_SHADER</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/vert.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">,</span> <span class="n">vertexShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/frag.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">,</span> <span class="n">fragmentShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glLinkProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glValidateProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glUseProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>

        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="c1">// Camera</span>
            <span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
                <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">parseShaderFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">)));</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span><span class="o">(</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
            <span class="o">{</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load shader from: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Application</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></table></code></div></div><h3 id="panning-the-camera"><span class="mr-2">Panning the Camera</span><a href="#panning-the-camera" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To pan our camera around we are going to start taking some user input. Inside of our <code class="language-plaintext highlighter-rouge">init</code> function we can declare some key call backs using glfw, in fact one is already defined for us to close the window when pressing escape. If you check out glfw’s <a href="https://www.glfw.org/docs/3.3/input_guide.html">input guide</a> you’ll note that the options available for <code class="language-plaintext highlighter-rouge">action</code> are <code class="language-plaintext highlighter-rouge">GLFW_PRESS</code>, <code class="language-plaintext highlighter-rouge">GLFW_RELEASE</code> and <code class="language-plaintext highlighter-rouge">GLFW_REPEAT</code>. As it turns out none of these allow for the pressing and holding of a key to move our camera around. Instead we are going to set up some booleans which are true only when the key is pressed, and then are false when it gets released. We can then poll these booleans within our main loop to move our camera around. Here is a quick example of how we would do so.</p><p>We will declare some booleans at the top of our <code class="language-plaintext highlighter-rouge">Application.java</code>:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Camera Panning Input</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</pre></table></code></div></div><p>Then we will modify these booleans in our key callback when their respective key is pressed or released:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="n">glfwSetKeyCallback</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">scancode</span><span class="o">,</span> <span class="n">action</span><span class="o">,</span> <span class="n">mods</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span> <span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span> <span class="o">)</span> <span class="o">{</span>
    <span class="n">glfwSetWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// We will detect this in the rendering loop</span>
  <span class="o">}</span>

  <span class="c1">// Up Arrow Key</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// Down Arrow Key</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// Left Arrow Key</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c1">// Right Arrow Key</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">});</span>
</pre></table></code></div></div><p>With that all setup its time to move the camera. In our main program loop we will check the value of these booleans every frame and if one is held we will pan our camera in that direction:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">cameraSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>

<span class="c1">// Run the rendering loop until the user has attempted to close</span>
<span class="c1">// the window or has pressed the ESCAPE key.</span>
<span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
  <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

  <span class="c1">// Camera Panning</span>
  <span class="k">if</span><span class="o">(</span><span class="n">upArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive y direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="n">cameraSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">downArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative y direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="o">-</span><span class="n">cameraSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">rightArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive x direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="n">cameraSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">leftArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative x direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(-</span><span class="n">cameraSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="c1">// Camera</span>
  <span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

  <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

  <span class="c1">// Poll for window events. The key callback above will only be</span>
  <span class="c1">// invoked during this call.</span>
  <span class="n">glfwPollEvents</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Here we are using JOML’s <code class="language-plaintext highlighter-rouge">translate</code> function to move our projection matrix by a 3 float vector. The 3 floats in this vector represent the x, y and z direction. For example when we press the up arrow key we move the projection matrix by the distance cameraSpeed specified above in the positive y direction.</p><p>If you now go ahead and run the program you can pan the camera using the arrow keys and it should be nice and smooth.</p><h3 id="zooming"><span class="mr-2">Zooming</span><a href="#zooming" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Zooming is relatively easy to implement using our projection. Lets first set up some more booleans for polling the zooming keys being held down. This will be just the same as it was for panning.</p><p>Here are our instance variables:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// Zooming</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</pre></table></code></div></div><p>Then we update them in the key callback, same as before:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// Zooming In (Z Key)</span>
<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Zooming Out (X Key)</span>
<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Now we can finally use these in our main loop to zoom in and out. Luckily for us, JOML provides quite a few different scaling functions. The one we are going to use is called <code class="language-plaintext highlighter-rouge">scaleLocal</code>. This scaling function will apply the scaling <em>after</em> any vector translation has been done (ie, after the camera’s position is taken into account). This works great for us as it means we can zoom the camera towards the center of it’s view no matter where it is positioned.</p><p>Here is how we are going to implement this zooming in our main loop:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Zooming</span>
<span class="k">if</span><span class="o">(</span><span class="n">zoomingIn</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="mf">1.05f</span><span class="o">);</span> <span class="c1">// Zoom In</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">zoomingOut</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">1.05f</span><span class="o">);</span> <span class="c1">// Zoom Out</span>
<span class="o">}</span>
</pre></table></code></div></div><p>If you now go ahead and run the program you’ll see you can now zoom in and out after panning the camera and all works smoothly. One problem does remain however. We aren’t modifying our panning speed based on how much we are zoomed in. This means after you zoom in a great distance panning feels insanely fast and jumps you across the screen. To counteract this we are going to keep track of how far the camera is zoomed and scale the panning speed based off of this value. Here is how I did that:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">basePanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
<span class="kt">float</span> <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
<span class="kt">float</span> <span class="n">zoomAmount</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="o">;</span>
<span class="kt">float</span> <span class="n">zoomSpeed</span> <span class="o">=</span> <span class="mf">1.05f</span><span class="o">;</span>

<span class="c1">// Run the rendering loop until the user has attempted to close</span>
<span class="c1">// the window or has pressed the ESCAPE key.</span>
<span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
  <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

  <span class="c1">// Camera Panning</span>
  <span class="k">if</span><span class="o">(</span><span class="n">upArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive y direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">downArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative y direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="o">-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">rightArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive x direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span><span class="n">leftArrow</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative x direction</span>
    <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="c1">// Zooming</span>
  <span class="k">if</span><span class="o">(</span><span class="n">zoomingIn</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="n">zoomSpeed</span><span class="o">;</span> <span class="c1">// Update the zoomAmount</span>
    <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

    <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom In</span>

  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">zoomingOut</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Update the zoomAmount</span>
    <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

    <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom Out</span>

  <span class="o">}</span>

  <span class="c1">// Camera</span>
  <span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
    <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
    <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

  <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

  <span class="c1">// Poll for window events. The key callback above will only be</span>
  <span class="c1">// invoked during this call.</span>
  <span class="n">glfwPollEvents</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>What I have done is created a variable called zoomAmount which keeps track of how far in we are currently zoomed. Therefore each time we zoom in I have to not only scale the projection matrix by zoomSpeed but also scale zoomAmount by zoomSpeed likewise. I can then use this zoomAmount to generate a new panningSpeed based off of the basePanningSpeed. With that in place we are done with the camera! For reference here is the entirety of <code class="language-plaintext highlighter-rouge">Application.java</code> with a working camera implemented:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.joml.Matrix4f</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.joml.Vector3f</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.glfw.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.opengl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.system.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">Callbacks</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">GLFW</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">opengl</span><span class="o">.</span><span class="na">GL11</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryStack</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryUtil</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="c1">// The window handle</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">window</span><span class="o">;</span>

    <span class="c1">// Projection Matrix</span>
    <span class="kd">private</span> <span class="nc">Matrix4f</span> <span class="n">pmatrix</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">ortho</span><span class="o">(-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">);</span>

    <span class="c1">// Camera Panning Input</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Zooming</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello LWJGL "</span> <span class="o">+</span> <span class="nc">Version</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>

        <span class="n">init</span><span class="o">();</span>
        <span class="n">loop</span><span class="o">();</span>

        <span class="c1">// Free the window callbacks and destroy the window</span>
        <span class="n">glfwFreeCallbacks</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="n">glfwDestroyWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>

        <span class="c1">// Terminate GLFW and free the error callback</span>
        <span class="n">glfwTerminate</span><span class="o">();</span>
        <span class="n">glfwSetErrorCallback</span><span class="o">(</span><span class="kc">null</span><span class="o">).</span><span class="na">free</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Setup an error callback. The default implementation</span>
        <span class="c1">// will print the error message in System.err.</span>
        <span class="nc">GLFWErrorCallback</span><span class="o">.</span><span class="na">createPrint</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">).</span><span class="na">set</span><span class="o">();</span>

        <span class="c1">// Initialize GLFW. Most GLFW functions will not work before doing this.</span>
        <span class="k">if</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwInit</span><span class="o">()</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Unable to initialize GLFW"</span><span class="o">);</span>

        <span class="c1">// Configure GLFW</span>
        <span class="n">glfwDefaultWindowHints</span><span class="o">();</span> <span class="c1">// optional, the current window hints are already the default</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_VISIBLE</span><span class="o">,</span> <span class="no">GLFW_FALSE</span><span class="o">);</span> <span class="c1">// the window will stay hidden after creation</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_RESIZABLE</span><span class="o">,</span> <span class="no">GLFW_TRUE</span><span class="o">);</span> <span class="c1">// the window will be resizable</span>

        <span class="c1">// Create the window</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="o">(</span><span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"Hello World!"</span><span class="o">,</span> <span class="no">NULL</span><span class="o">,</span> <span class="no">NULL</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span> <span class="n">window</span> <span class="o">==</span> <span class="no">NULL</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Failed to create the GLFW window"</span><span class="o">);</span>

        <span class="c1">// Setup a key callback. It will be called every time a key is pressed, repeated or released.</span>
        <span class="n">glfwSetKeyCallback</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">scancode</span><span class="o">,</span> <span class="n">action</span><span class="o">,</span> <span class="n">mods</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span> <span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">glfwSetWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// We will detect this in the rendering loop</span>
            <span class="o">}</span>

            <span class="c1">// Up Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Down Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Left Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Right Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Zooming In (Z Key)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Zooming Out (X Key)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">});</span>

        <span class="c1">// Get the thread stack and push a new frame</span>
        <span class="k">try</span> <span class="o">(</span> <span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">stackPush</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
            <span class="nc">IntBuffer</span> <span class="n">pWidth</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>
            <span class="nc">IntBuffer</span> <span class="n">pHeight</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>

            <span class="c1">// Get the window size passed to glfwCreateWindow</span>
            <span class="n">glfwGetWindowSize</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">pWidth</span><span class="o">,</span> <span class="n">pHeight</span><span class="o">);</span>

            <span class="c1">// Get the resolution of the primary monitor</span>
            <span class="nc">GLFWVidMode</span> <span class="n">vidmode</span> <span class="o">=</span> <span class="n">glfwGetVideoMode</span><span class="o">(</span><span class="n">glfwGetPrimaryMonitor</span><span class="o">());</span>

            <span class="c1">// Center the window</span>
            <span class="n">glfwSetWindowPos</span><span class="o">(</span>
                    <span class="n">window</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">-</span> <span class="n">pWidth</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">height</span><span class="o">()</span> <span class="o">-</span> <span class="n">pHeight</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="o">);</span>
        <span class="o">}</span> <span class="c1">// the stack frame is popped automatically</span>

        <span class="c1">// Make the OpenGL context current</span>
        <span class="n">glfwMakeContextCurrent</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="c1">// Enable v-sync</span>
        <span class="n">glfwSwapInterval</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Make the window visible</span>
        <span class="n">glfwShowWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Vertices - Positions</span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
                <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
                 <span class="mf">1.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
                 <span class="mf">1.0f</span><span class="o">,</span>  <span class="mf">1.0f</span>    <span class="c1">// Vertex 3</span>
        <span class="o">};</span>

        <span class="c1">// VBO (Vertex Buffer Object)</span>
        <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">// Indices</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
            <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
            <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
        <span class="o">};</span>

        <span class="c1">// IBO (Index Buffer Object)</span>
        <span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>

        <span class="c1">// Shaders</span>
        <span class="kt">int</span> <span class="n">programID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateProgram</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">vertShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_VERTEX_SHADER</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">fragShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_FRAGMENT_SHADER</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/vert.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">,</span> <span class="n">vertexShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/frag.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">,</span> <span class="n">fragmentShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glLinkProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glValidateProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glUseProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>

        <span class="kt">float</span> <span class="n">basePanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">zoomAmount</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">zoomSpeed</span> <span class="o">=</span> <span class="mf">1.05f</span><span class="o">;</span>

        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="c1">// Camera Panning</span>
            <span class="k">if</span><span class="o">(</span><span class="n">upArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive y direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">downArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative y direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="o">-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rightArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive x direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">leftArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative x direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="c1">// Zooming</span>
            <span class="k">if</span><span class="o">(</span><span class="n">zoomingIn</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="n">zoomSpeed</span><span class="o">;</span> <span class="c1">// Update the zoomAmount</span>
                <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

                <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom In</span>

            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">zoomingOut</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Update the zoomAmount</span>
                <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

                <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom Out</span>

            <span class="o">}</span>

            <span class="c1">// Camera</span>
            <span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
                <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">parseShaderFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">)));</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span><span class="o">(</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
            <span class="o">{</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load shader from: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Application</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h2 id="the-mandelbrot-set-fractal"><span class="mr-2">The Mandelbrot Set Fractal</span><a href="#the-mandelbrot-set-fractal" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>If you aren’t already aware of how the Mandelbrot Set works I will attempt to give a brief overview here but I recommend checking out some resources much better at explaining it than me such as <a href="https://www.youtube.com/watch?v=NGMRB4O922I">this numberphile video</a> or <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">the wikipedia page</a>.</p><p>The Mandelbrot Set is a set of complex numbers which when drawn on the complex plane produces a very distinct pattern. This pattern is known as a fractal because you can infinitely zoom into the complex plane and it will produce different patterns as you continue to zoom forever. The Mandelbrot Set is one of the more popular fractals because it is simple enough to understand and produces some incredible patterns when colored using a good coloring function. The main goal of this tutorial series was to create this fractal using a shader in OpenGL and explore the infinite patterns it produces by panning around and zooming in and out.</p><p>To get started we first need a tiny bit of maths. I believe wikipedia’s explanation is best:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_7.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_7.png" data-proofer-ignore></p><p>Since we are dealing with complex numbers we can simply use the 2D coordinates of our screen as the complex plane. You may remember from part one that our fragment shader is run on every pixel in between the vertices of our square so this is perfect for us. Our 2D coordinates are stored in <code class="language-plaintext highlighter-rouge">vec2</code>’s in OpenGL making treating them as complex numbers easy. One of the basic properties of the Mandelbrot Set is that it is compact, meaning it is all contained within a radius 2 circle around the origin of the complex plane. Now it should make sense why we made the bounds of our camera range from -2.0 to 2.0. A point is considered to belong to the set if, after a certain number of iterations of the function listed above, the magnitude of the complex number never becomes greater than 2. This number of iterations is something we can control within our code and the more iterations you check for every pixel, the more precise the mandelbrot set image. However, this does come at the cost of performance as there are more calculations being done per pixel.</p><p>Hopefully my explanation was somewhat clear but if not I once again recommend the tutorials linked above. Finally we can get to generating the set ourselves. First off we should begin by making our square fill the entire -2.0 to 2.0 screen size by replacing the vertices positions array with the following:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// Vertices - Positions</span>
<span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
  		<span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>  <span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
  		<span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
  		 <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
  		 <span class="mf">2.0f</span><span class="o">,</span>  <span class="mf">2.0f</span>    <span class="c1">// Vertex 3</span>
<span class="o">};</span>
</pre></table></code></div></div><p>Now that our square fills the screen we can get to writing our fragment shader.</p><h3 id="the-fragment-shader"><span class="mr-2">The Fragment Shader</span><a href="#the-fragment-shader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>To begin writing our fragment shader we are going to need some way to reference the current pixel position the fragment shader is being applied to. To do this we will pass the position from the vertex shader to the fragment shader. The passing of data between shaders is done using something called a varying. Varying’s can be declared using the <code class="language-plaintext highlighter-rouge">out</code> and <code class="language-plaintext highlighter-rouge">in</code> keyword. Here is how we do this and a quick test to make sure it works:</p><p><strong>Vertex Shader</strong></p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">position</span><span class="p">;</span>

<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">u_MVP</span><span class="p">;</span>

<span class="k">out</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">u_MVP</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">v_Pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>Fragment Shader</strong></p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">in</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">v_Pos</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see I have created a varying called <code class="language-plaintext highlighter-rouge">v_Pos</code> in the vertex shader (I like to use the convention of a v_Something for varying) and declared it as going <code class="language-plaintext highlighter-rouge">out</code> from the vertex shader. I then set it equal to the position in the main function. In the fragment shader I take <code class="language-plaintext highlighter-rouge">in</code> this varying and then use it in a quick test to draw the right quarter of the square as purple and the rest black. If everything works correctly the square will look like this:</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_8.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_8.png" data-proofer-ignore></p><p>Now that that is set up we can begin implementing the Mandelbrot Set’s function. If you remember the function requires the squaring of an imaginary number. I could not find any built in OpenGL functions for doing this using a <code class="language-plaintext highlighter-rouge">vec2</code> so I’ve gone ahead and wrote my own:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">vec2</span> <span class="nf">squareImaginary</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">imaginaryNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">imaginaryResult</span><span class="p">;</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">imaginaryResult</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(If you want to get better at using GLSL I recommend <a href="https://www.youtube.com/watch?v=HIvNePu7UEE&amp;list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7">this</a> video series which I mentioned in <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">part one</a>)</p><p>Then in our main line we can use it to generate a black and white version of the Mandelbrot Set:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">in</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">vec2</span> <span class="nf">squareImaginary</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">imaginaryNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">imaginaryResult</span><span class="p">;</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">imaginaryResult</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">v_Pos</span><span class="p">;</span>      <span class="c1">// c starts as the current position</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>          <span class="c1">// We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c</span>

    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// The default color will be black</span>
    <span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 100 is a good number of iterations</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not</span>
        <span class="kt">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">squareImaginary</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This is a point not in the mandelbrot set - Change color to white</span>
            <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Color the point</span>
    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You can already pan around and zoom in and potentially see some cool patterns but since it is just black and white it may not look too great.</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_9.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_9.png" data-proofer-ignore></p><h3 id="coloring-function"><span class="mr-2">Coloring Function</span><a href="#coloring-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>If you have ever seen videos or pictures of the Mandelbrot Set it likely was colored in some way to make it look much better and make the patterns more impressive. To achieve this effect we are going to use a coloring function. If you wish to learn about lots of various coloring methods and how they work check out <a href="https://www.math.univ-toulouse.fr/~cheritat/wiki-draw/index.php/Mandelbrot_set">this</a> web page on the topic.</p><p>One coloring technique mentioned on that website is “escape time based coloring”. With this technique instead of coloring pixels not within the set white if its length becomes &gt;2 we will color the pixel based on the number of iterations it took to become &gt;2. To implement this we simply have to make one small modification to our main function inside the fragment shader:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not</span>
    <span class="kt">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">squareImaginary</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
   	<span class="k">if</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// This is a point not in the mandelbrot set - Change color based on iterations</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">colorFunc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Here i is our number of iterations so we are going to pass this value to a special color function which returns a color based on it. There are many ways we could define such a color function but I chose to use HSV values where the Hue and Value are based on the number of iterations. This HSV value is then converted to RGB and returned by the function.</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">vec3</span> <span class="nf">colorFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Color in HSV - Tweak these values to your liking and for different coloring effects</span>
    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">012</span><span class="o">*</span><span class="n">iter</span> <span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="o">+</span><span class="p">.</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="o">*</span><span class="n">iter</span><span class="p">)));</span>

    <span class="c1">// Convert from HSV to RGB</span>
    <span class="c1">// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl</span>
    <span class="kt">vec4</span> <span class="n">K</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">vec3</span> <span class="n">m</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">fract</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">xxx</span> <span class="o">+</span> <span class="n">K</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">www</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">mix</span><span class="p">(</span><span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">clamp</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Our full fragment shader for generating the Mandelbrot Set is now complete! Here is it in its entirety:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">in</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">vec2</span> <span class="nf">squareImaginary</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">imaginaryNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">imaginaryResult</span><span class="p">;</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">imaginaryResult</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">vec3</span> <span class="nf">colorFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Color in HSV - Tweak these values to your liking and for different coloring effects</span>
    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">012</span><span class="o">*</span><span class="n">iter</span> <span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="o">+</span><span class="p">.</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="o">*</span><span class="n">iter</span><span class="p">)));</span>

    <span class="c1">// Convert from HSV to RGB</span>
    <span class="c1">// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl</span>
    <span class="kt">vec4</span> <span class="n">K</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">vec3</span> <span class="n">m</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">fract</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">xxx</span> <span class="o">+</span> <span class="n">K</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">www</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">mix</span><span class="p">(</span><span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">clamp</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">v_Pos</span><span class="p">;</span>      <span class="c1">// c starts as the current position</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>          <span class="c1">// We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c</span>

    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// The default color will be black</span>
    <span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 100 is a good number of iterations</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not</span>
        <span class="kt">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">squareImaginary</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This is a point not in the mandelbrot set - Change color based on iterations</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colorFunc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Color the point</span>
    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Running the program and exploring around will produce all kinds of incredible fractal patterns (If you haven’t already you could switch the program resolution from 480x480 to 960x960 now as it will look much better):</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_10.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_10.png" data-proofer-ignore></p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_11.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_11.png" data-proofer-ignore></p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_12.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_12.png" data-proofer-ignore></p><h2 id="limitations"><span class="mr-2">Limitations</span><a href="#limitations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Now that we’ve finally completed the project I wanted to discuss some of the limitations of the implementation and perhaps lay out some future tasks for you to try.</p><p>You may have already noticed that if you zoom in far enough on the set it will begin to break down and look more and more pixelated until you cannot zoom anymore.</p><p><img data-src="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_13.png" alt="/assets/img/post/OpenGLMandelbrot/OpenGL_Tutorial_Mandelbrot_13.png" data-proofer-ignore></p><p>The reason for this is due to the fact that OpenGL handles everything in 32-bit floats. We use these floats for our vertices data, our camera position and within our shader code. This means that as you zoom in more and more you start to deal with smaller and smaller numbers until they are too small to be represented by a float. One quick improvement for this can be done by adding this line to the top of the fragment shader:</p><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">precision</span> <span class="kt">highp</span> <span class="kt">float</span><span class="p">;</span>
</pre></table></code></div></div><p>However, this change will be quite minute. Instead the best way to improve this would be to switch from using floats to doubles. OpenGL does in fact support the use of doubles for both vertex attributes and uniforms as of a somewhat recent update. As a possible task to test what you’ve learned you could try implementing this program from scratch using doubles. <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_gpu_shader_fp64.txt">This update</a> adds double uniforms and <a href="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_vertex_attrib_64bit.txt">this one</a> adds support for double vertex attributes and each will detail the required functions. One thing to note is we used JOML Matrices of type float, <code class="language-plaintext highlighter-rouge">Matrix4f</code>, but you can use doubles by doing <code class="language-plaintext highlighter-rouge">Matrix4d</code>. If you do manage to get this working please share it with me in the comments!</p><p>One final challenge would be to create an infinite zoom. Some online resources detail how to do this using a lot of vector math or OpenCL (OpenGL for computing tasks) but I will leave research of this up to you.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>That’s it for the tutorial series! If you came all the way from the beginning, thanks so much for reading all the way through and even if you didn’t thanks so much for reading in general. I hope my explanations were clear and well understood. If you did note any problems leave a comment so I can possibly make some additions or changes in the future. As I mentioned in <a href="https://cianjinks.github.io/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">part one</a> if you want to check out my original version of this project it can be found on my <a href="https://github.com/cianjinks/MandelbrotViewer">github</a>. (This version has an implemented UI and settings and as well as that a lot of concepts covered here such as the Camera are abstracted into their own classes)</p><p>- Cian Jinks</p><h2 id="full-source-code"><span class="mr-2">Full Source Code</span><a href="#full-source-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="applicationjava"><span class="mr-2">Application.java</span><a href="#applicationjava" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.joml.Matrix4f</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.joml.Vector3f</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.glfw.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.opengl.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.lwjgl.system.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">Callbacks</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">glfw</span><span class="o">.</span><span class="na">GLFW</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">opengl</span><span class="o">.</span><span class="na">GL11</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryStack</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">lwjgl</span><span class="o">.</span><span class="na">system</span><span class="o">.</span><span class="na">MemoryUtil</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="c1">// The window handle</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">window</span><span class="o">;</span>

    <span class="c1">// Projection Matrix</span>
    <span class="kd">private</span> <span class="nc">Matrix4f</span> <span class="n">pmatrix</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Matrix4f</span><span class="o">().</span><span class="na">ortho</span><span class="o">(-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">1.0f</span><span class="o">);</span>

    <span class="c1">// Camera Panning Input</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="c1">// Zooming</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello LWJGL "</span> <span class="o">+</span> <span class="nc">Version</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">);</span>

        <span class="n">init</span><span class="o">();</span>
        <span class="n">loop</span><span class="o">();</span>

        <span class="c1">// Free the window callbacks and destroy the window</span>
        <span class="n">glfwFreeCallbacks</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="n">glfwDestroyWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>

        <span class="c1">// Terminate GLFW and free the error callback</span>
        <span class="n">glfwTerminate</span><span class="o">();</span>
        <span class="n">glfwSetErrorCallback</span><span class="o">(</span><span class="kc">null</span><span class="o">).</span><span class="na">free</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Setup an error callback. The default implementation</span>
        <span class="c1">// will print the error message in System.err.</span>
        <span class="nc">GLFWErrorCallback</span><span class="o">.</span><span class="na">createPrint</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">).</span><span class="na">set</span><span class="o">();</span>

        <span class="c1">// Initialize GLFW. Most GLFW functions will not work before doing this.</span>
        <span class="k">if</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwInit</span><span class="o">()</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"Unable to initialize GLFW"</span><span class="o">);</span>

        <span class="c1">// Configure GLFW</span>
        <span class="n">glfwDefaultWindowHints</span><span class="o">();</span> <span class="c1">// optional, the current window hints are already the default</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_VISIBLE</span><span class="o">,</span> <span class="no">GLFW_FALSE</span><span class="o">);</span> <span class="c1">// the window will stay hidden after creation</span>
        <span class="n">glfwWindowHint</span><span class="o">(</span><span class="no">GLFW_RESIZABLE</span><span class="o">,</span> <span class="no">GLFW_TRUE</span><span class="o">);</span> <span class="c1">// the window will be resizable</span>

        <span class="c1">// Create the window</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">glfwCreateWindow</span><span class="o">(</span><span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">960</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"Hello World!"</span><span class="o">,</span> <span class="no">NULL</span><span class="o">,</span> <span class="no">NULL</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span> <span class="n">window</span> <span class="o">==</span> <span class="no">NULL</span> <span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Failed to create the GLFW window"</span><span class="o">);</span>

        <span class="c1">// Setup a key callback. It will be called every time a key is pressed, repeated or released.</span>
        <span class="n">glfwSetKeyCallback</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">scancode</span><span class="o">,</span> <span class="n">action</span><span class="o">,</span> <span class="n">mods</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span> <span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_ESCAPE</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">glfwSetWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// We will detect this in the rendering loop</span>
            <span class="o">}</span>

            <span class="c1">// Up Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_UP</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">upArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Down Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_DOWN</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">downArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Left Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leftArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Right Arrow Key</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_RIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">rightArrow</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Zooming In (Z Key)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_Z</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingIn</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Zooming Out (X Key)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_PRESS</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="no">GLFW_KEY_X</span> <span class="o">&amp;&amp;</span> <span class="n">action</span> <span class="o">==</span> <span class="no">GLFW_RELEASE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomingOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">});</span>

        <span class="c1">// Get the thread stack and push a new frame</span>
        <span class="k">try</span> <span class="o">(</span> <span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">stackPush</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
            <span class="nc">IntBuffer</span> <span class="n">pWidth</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>
            <span class="nc">IntBuffer</span> <span class="n">pHeight</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">mallocInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// int*</span>

            <span class="c1">// Get the window size passed to glfwCreateWindow</span>
            <span class="n">glfwGetWindowSize</span><span class="o">(</span><span class="n">window</span><span class="o">,</span> <span class="n">pWidth</span><span class="o">,</span> <span class="n">pHeight</span><span class="o">);</span>

            <span class="c1">// Get the resolution of the primary monitor</span>
            <span class="nc">GLFWVidMode</span> <span class="n">vidmode</span> <span class="o">=</span> <span class="n">glfwGetVideoMode</span><span class="o">(</span><span class="n">glfwGetPrimaryMonitor</span><span class="o">());</span>

            <span class="c1">// Center the window</span>
            <span class="n">glfwSetWindowPos</span><span class="o">(</span>
                    <span class="n">window</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">-</span> <span class="n">pWidth</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                    <span class="o">(</span><span class="n">vidmode</span><span class="o">.</span><span class="na">height</span><span class="o">()</span> <span class="o">-</span> <span class="n">pHeight</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="o">);</span>
        <span class="o">}</span> <span class="c1">// the stack frame is popped automatically</span>

        <span class="c1">// Make the OpenGL context current</span>
        <span class="n">glfwMakeContextCurrent</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
        <span class="c1">// Enable v-sync</span>
        <span class="n">glfwSwapInterval</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// Make the window visible</span>
        <span class="n">glfwShowWindow</span><span class="o">(</span><span class="n">window</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">loop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// This line is critical for LWJGL's interoperation with GLFW's</span>
        <span class="c1">// OpenGL context, or any context that is managed externally.</span>
        <span class="c1">// LWJGL detects the context that is current in the current thread,</span>
        <span class="c1">// creates the GLCapabilities instance and makes the OpenGL</span>
        <span class="c1">// bindings available for use.</span>
        <span class="no">GL</span><span class="o">.</span><span class="na">createCapabilities</span><span class="o">();</span>

        <span class="c1">// Set the clear color</span>
        <span class="n">glClearColor</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">);</span>

        <span class="c1">// Vertices - Positions</span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[]</span> <span class="o">{</span>
                <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>  <span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 0</span>
                <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 1</span>
                 <span class="mf">2.0f</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0f</span><span class="o">,</span>   <span class="c1">// Vertex 2</span>
                 <span class="mf">2.0f</span><span class="o">,</span>  <span class="mf">2.0f</span>    <span class="c1">// Vertex 3</span>
        <span class="o">};</span>

        <span class="c1">// VBO (Vertex Buffer Object)</span>
        <span class="nc">FloatBuffer</span> <span class="n">vboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createFloatBuffer</span><span class="o">(</span><span class="n">vertices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">float</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">vertices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">vboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">vertex</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">vboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">positionElementCount</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">vboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">vboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glVertexAttribPointer</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">positionElementCount</span><span class="o">,</span> <span class="no">GL_FLOAT</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">positionElementCount</span> <span class="o">*</span> <span class="nc">Float</span><span class="o">.</span><span class="na">BYTES</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glEnableVertexAttribArray</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="c1">// Indices</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">indices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span>
            <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
            <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span>
        <span class="o">};</span>

        <span class="c1">// IBO (Index Buffer Object)</span>
        <span class="nc">IntBuffer</span> <span class="n">iboBuffer</span> <span class="o">=</span> <span class="nc">BufferUtils</span><span class="o">.</span><span class="na">createIntBuffer</span><span class="o">(</span><span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">indices</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">iboBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">iboBuffer</span><span class="o">.</span><span class="na">flip</span><span class="o">();</span>

        <span class="c1">// Pass data to GPU</span>
        <span class="kt">int</span> <span class="n">iboID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGenBuffers</span><span class="o">();</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBindBuffer</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glBufferData</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_ELEMENT_ARRAY_BUFFER</span><span class="o">,</span> <span class="n">iboBuffer</span><span class="o">,</span> <span class="no">GL30</span><span class="o">.</span><span class="na">GL_STATIC_DRAW</span><span class="o">);</span>

        <span class="c1">// Shaders</span>
        <span class="kt">int</span> <span class="n">programID</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateProgram</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">vertShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_VERTEX_SHADER</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">fragShaderObj</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glCreateShader</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_FRAGMENT_SHADER</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">vertexShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/vert.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">,</span> <span class="n">vertexShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">parseShaderFromFile</span><span class="o">(</span><span class="s">"/shaders/frag.shader"</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glShaderSource</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">,</span> <span class="n">fragmentShader</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glCompileShader</span><span class="o">(</span><span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">vertShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glAttachShader</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="n">fragShaderObj</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glLinkProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glValidateProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>
        <span class="no">GL30</span><span class="o">.</span><span class="na">glUseProgram</span><span class="o">(</span><span class="n">programID</span><span class="o">);</span>

        <span class="kt">float</span> <span class="n">basePanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="mf">0.0125f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">zoomAmount</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">zoomSpeed</span> <span class="o">=</span> <span class="mf">1.05f</span><span class="o">;</span>

        <span class="c1">// Run the rendering loop until the user has attempted to close</span>
        <span class="c1">// the window or has pressed the ESCAPE key.</span>
        <span class="k">while</span> <span class="o">(</span> <span class="o">!</span><span class="n">glfwWindowShouldClose</span><span class="o">(</span><span class="n">window</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">glClear</span><span class="o">(</span><span class="no">GL_COLOR_BUFFER_BIT</span> <span class="o">|</span> <span class="no">GL_DEPTH_BUFFER_BIT</span><span class="o">);</span> <span class="c1">// clear the framebuffer</span>

            <span class="c1">// Camera Panning</span>
            <span class="k">if</span><span class="o">(</span><span class="n">upArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive y direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">downArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative y direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="mf">0.0f</span><span class="o">,</span> <span class="o">-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rightArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the positive x direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">leftArrow</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Translate the projection matrix by the distance cameraSpeed in the negative x direction</span>
                <span class="n">pmatrix</span><span class="o">.</span><span class="na">translate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Vector3f</span><span class="o">(-</span><span class="n">currentPanningSpeed</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">,</span> <span class="mf">0.0f</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="c1">// Zooming</span>
            <span class="k">if</span><span class="o">(</span><span class="n">zoomingIn</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="n">zoomSpeed</span><span class="o">;</span> <span class="c1">// Update the zoomAmount</span>
                <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

                <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom In</span>

            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">zoomingOut</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">zoomAmount</span> <span class="o">=</span> <span class="n">zoomAmount</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Update the zoomAmount</span>
                <span class="n">currentPanningSpeed</span> <span class="o">=</span> <span class="n">basePanningSpeed</span> <span class="o">/</span> <span class="n">zoomAmount</span><span class="o">;</span> <span class="c1">// Update camera panning speed</span>

                <span class="n">pmatrix</span><span class="o">.</span><span class="na">scaleLocal</span><span class="o">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">zoomSpeed</span><span class="o">);</span> <span class="c1">// Zoom Out</span>

            <span class="o">}</span>

            <span class="c1">// Camera</span>
            <span class="k">try</span> <span class="o">(</span><span class="nc">MemoryStack</span> <span class="n">stack</span> <span class="o">=</span> <span class="nc">MemoryStack</span><span class="o">.</span><span class="na">stackPush</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">FloatBuffer</span> <span class="n">projection</span> <span class="o">=</span> <span class="n">pmatrix</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">mallocFloat</span><span class="o">(</span><span class="mi">4</span> <span class="o">*</span> <span class="mi">4</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">mat4location</span> <span class="o">=</span> <span class="no">GL30</span><span class="o">.</span><span class="na">glGetUniformLocation</span><span class="o">(</span><span class="n">programID</span><span class="o">,</span> <span class="s">"u_MVP"</span><span class="o">);</span>
                <span class="no">GL30</span><span class="o">.</span><span class="na">glUniformMatrix4fv</span><span class="o">(</span><span class="n">mat4location</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">projection</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="no">GL30</span><span class="o">.</span><span class="na">glDrawElements</span><span class="o">(</span><span class="no">GL30</span><span class="o">.</span><span class="na">GL_TRIANGLES</span><span class="o">,</span> <span class="n">indices</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="no">GL_UNSIGNED_INT</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span> <span class="c1">//Draw our square</span>

            <span class="n">glfwSwapBuffers</span><span class="o">(</span><span class="n">window</span><span class="o">);</span> <span class="c1">// swap the color buffers</span>

            <span class="c1">// Poll for window events. The key callback above will only be</span>
            <span class="c1">// invoked during this call.</span>
            <span class="n">glfwPollEvents</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">parseShaderFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">line</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">)));</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="k">while</span><span class="o">(</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
            <span class="o">{</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
                <span class="n">data</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Unable to load shader from: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Application</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><h3 id="shadersvertshader"><span class="mr-2">/shaders/vert.shader</span><a href="#shadersvertshader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec2</span> <span class="n">position</span><span class="p">;</span>

<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">u_MVP</span><span class="p">;</span>

<span class="k">out</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">u_MVP</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">v_Pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="shadersfragshader"><span class="mr-2">/shaders/frag.shader</span><a href="#shadersfragshader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-glsl highlighter-rouge"><div class="code-header"> <span data-label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="k">precision</span> <span class="kt">highp</span> <span class="kt">float</span><span class="p">;</span>

<span class="k">in</span> <span class="kt">vec2</span> <span class="n">v_Pos</span><span class="p">;</span>

<span class="kt">vec2</span> <span class="nf">squareImaginary</span><span class="p">(</span><span class="kt">vec2</span> <span class="n">imaginaryNum</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">imaginaryResult</span><span class="p">;</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">imaginaryResult</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">imaginaryNum</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">imaginaryResult</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">vec3</span> <span class="nf">colorFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Color in HSV - Tweak these values to your liking and for different coloring effects</span>
    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">012</span><span class="o">*</span><span class="n">iter</span> <span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="o">+</span><span class="p">.</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="o">*</span><span class="n">iter</span><span class="p">)));</span>

    <span class="c1">// Convert from HSV to RGB</span>
    <span class="c1">// Taken from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl</span>
    <span class="kt">vec4</span> <span class="n">K</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">vec3</span> <span class="n">m</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">fract</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">xxx</span> <span class="o">+</span> <span class="n">K</span><span class="p">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">*</span> <span class="mi">6</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">www</span><span class="p">);</span>
    <span class="k">return</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">mix</span><span class="p">(</span><span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="n">clamp</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">K</span><span class="p">.</span><span class="n">xxx</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span> <span class="n">color</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">vec2</span> <span class="n">c</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">v_Pos</span><span class="p">;</span>      <span class="c1">// c starts as the current position</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>          <span class="c1">// We can skip one iteration of the function where z = 0 as it is uneccessary if we simply set z = c</span>

    <span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// The default color will be black</span>
    <span class="kt">int</span> <span class="n">iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 100 is a good number of iterations</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fc(z) = z^2 + c - Here we iterate over this function until it either becomes greater than 2 or not</span>
        <span class="kt">vec2</span> <span class="n">result</span> <span class="o">=</span> <span class="n">squareImaginary</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This is a point not in the mandelbrot set - Change color based on iterations</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">colorFunc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Color the point</span>
    <span class="nb">gl_FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/old/'>Old</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/opengl/" class="post-tag no-text-decoration" >opengl</a> <a href="/tags/lwjgl/" class="post-tag no-text-decoration" >lwjgl</a> <a href="/tags/fractal/" class="post-tag no-text-decoration" >fractal</a> <a href="/tags/tutorial/" class="post-tag no-text-decoration" >tutorial</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2 - Cian Jinks&amp;url=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2 - Cian Jinks&amp;u=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://cianjinks.github.io//posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/&amp;text=OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2 - Cian Jinks" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/cmake-project-graphics-programming/">Creating a CMake Project for cross platform graphics programming with OpenGL</a><li><a href="/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/">OpenGL Tutorial - Batch Rendering and Dynamic VBOs</a><li><a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/">OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2</a><li><a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/">Tutorial - Using Maven and IntelliJ for OpenGL Projects</a><li><a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-part-2-of-2/">OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 2 of 2</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/lwjgl/">lwjgl</a> <a class="post-tag" href="/tags/fractal/">fractal</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/imgui/">imgui</a> <a class="post-tag" href="/tags/maven/">maven</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/opengl-tutorial-visualizing-the-mandelbrot-set-fractal-part-1-of-2/"><div class="card-body"> <em class="timeago small" data-ts="1589630400" > 2020-05-16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenGL Tutorial - Visualizing the Mandelbrot Set Fractal - Part 1 of 2</h3><div class="text-muted small"><p> Welcome to my first blog post/tutorial of many I hope to create on the topic of computer graphics programming using OpenGL. Over the past half a year or so I have been spending a large portion of m...</p></div></div></a></div><div class="card"> <a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/"><div class="card-body"> <em class="timeago small" data-ts="1590667200" > 2020-05-28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tutorial - Using Maven and IntelliJ for OpenGL Projects</h3><div class="text-muted small"><p> This tutorial will quickly cover how one can use Maven along with IntelliJ to get started with graphics programming using OpenGL. I originally wrote this so people could use it to directly follow a...</p></div></div></a></div><div class="card"> <a href="/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/"><div class="card-body"> <em class="timeago small" data-ts="1591963200" > 2020-06-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OpenGL Tutorial - Batch Rendering and Dynamic VBOs</h3><div class="text-muted small"><p> Hello and welcome to my second ever tutorial on computer graphics programming using OpenGL. My previous tutorials covered many of the basics of OpenGL such as VBOs, IBOs, Shaders and MVP Matrices b...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/tutorial-using-maven-and-intellij-for-opengl-projects/" class="btn btn-outline-primary" prompt="Older"><p>Tutorial - Using Maven and IntelliJ for OpenGL Projects</p></a> <a href="/posts/opengl-tutorial-batch-rendering-and-dynamic-vbos/" class="btn btn-outline-primary" prompt="Newer"><p>OpenGL Tutorial - Batch Rendering and Dynamic VBOs</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/cianjinks">Cian Jinks</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/lwjgl/">lwjgl</a> <a class="post-tag" href="/tags/fractal/">fractal</a> <a class="post-tag" href="/tags/cmake/">cmake</a> <a class="post-tag" href="/tags/ctf/">ctf</a> <a class="post-tag" href="/tags/imgui/">imgui</a> <a class="post-tag" href="/tags/maven/">maven</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-BJS97N23FL"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-BJS97N23FL'); }); </script>
